"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverProductionEntryPlugin = serverProductionEntryPlugin;
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const serverEntryFileNameBase_1 = require("../shared/serverEntryFileNameBase");
const debugLogsBuildTime_1 = require("./debugLogsBuildTime");
const indexEntryName = 'index';
const autoImporterFilePath = require.resolve('../runtime/autoImporter.js');
const serverEntryVirtualId = 'virtual:@brillout/vite-plugin-server-entry:serverEntry';
// https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
const virtualIdPrefix = '\0';
// Using the semver major to determine compatible versions is a much inferior solution. Because, for example, when the user updates Vike > @brillout/vite-plugin-server-entry from version 0.4.8 (`apiVersion===4`) to 0.4.10 (`apiVersion===5`) then things just works because Telefunc > @brillout/vite-plugin-server-entry also updates to `0.4.10`. On the other hand, when the user updates Vike > @brillout/vite-plugin-server-entry to 0.5.0 then this won't update Telefunc > @brillout/vite-plugin-server-entry which is stuck to 0.4.x and the user is forced to update Telefunc.
const apiVersion = 5;
/**
 * This plugin does two things:
 *  - Generates a "server entry" file at `dist/server/entry.js`.
 *  - Generates a "auto importer" file at `node_modules/@brillout/vite-plugin-server-entry/dist/runtime/autoImporter.js`.
 *
 * See https://github.com/brillout/vite-plugin-server-entry#what-it-does for more information.
 */
function serverProductionEntryPlugin(pluginConfigProvidedByLibrary) {
    const pluginName = `@brillout/vite-plugin-server-entry:${pluginConfigProvidedByLibrary.libraryName.toLowerCase()}`;
    let config;
    let injectEntries;
    let library;
    let skip;
    let injectDone = false;
    return [
        {
            name: pluginName,
            apply: 'build',
            // We need to run this plugin after other plugin instances, so that assertApiVersions() works also for libraries using older plugin versions
            enforce: 'post',
            configResolved() {
                if (skip)
                    return;
                if (!isLeaderPluginInstance(config, library)) {
                    skip = true;
                    return;
                }
                assertApiVersions(config, pluginConfigProvidedByLibrary.libraryName);
                applyPluginConfigProvidedByUser(config);
                if (!config._vitePluginServerEntry.inject) {
                    const serverEntryName = getServerEntryName(config);
                    config.build.rollupOptions.input = (0, utils_1.injectRollupInputs)({ [serverEntryName]: serverEntryVirtualId }, config);
                }
            },
            buildStart() {
                if (skip)
                    return;
                injectEntries = config._vitePluginServerEntry.inject ? getInjectEntries(config) : null;
                clearAutoImporter(config);
            },
            resolveId(id) {
                if (skip)
                    return;
                if (id === serverEntryVirtualId) {
                    return virtualIdPrefix + serverEntryVirtualId;
                }
            },
            load(id) {
                if (skip)
                    return;
                (0, utils_1.assert)(id !== serverEntryVirtualId);
                if (id === virtualIdPrefix + serverEntryVirtualId) {
                    const serverProductionEntry = getServerProductionEntryAll(config);
                    return serverProductionEntry;
                }
            },
            generateBundle(_rollupOptions, bundle) {
                if (skip)
                    return;
                const { inject } = config._vitePluginServerEntry;
                if (inject) {
                    (0, utils_1.assert)(injectDone);
                }
                // Write node_modules/@brillout/vite-plugin-server-entry/dist/autoImporter.js
                if (!isAutoImportDisabled(config)) {
                    const entry = findServerEntry(bundle);
                    (0, utils_1.assert)(!inject && entry);
                    const entryFileName = entry.fileName;
                    writeAutoImporterFile(config, entryFileName);
                }
                else {
                    (0, debugLogsBuildTime_1.debugLogsBuildtime)({ disabled: true, paths: null });
                }
            },
            transform(code, id) {
                if (skip)
                    return;
                if (!config._vitePluginServerEntry.inject)
                    return;
                (0, utils_1.assert)(injectEntries);
                if (!injectEntries.includes(id))
                    return;
                {
                    const moduleInfo = this.getModuleInfo(id);
                    (0, utils_1.assert)(moduleInfo?.isEntry);
                }
                injectDone = true;
                code = [
                    /* We don't do this, instead let Vike's CLI handle the default process.env.NODE_ENV value.
                    "process.env.NODE_ENV = 'production';", */
                    // Imports the entry of each tool, e.g. the Vike entry and the Telefunc entry.
                    `import '${serverEntryVirtualId}';`,
                    code
                ].join(''
                /* We don't insert new lines, otherwise we break the source map.
              '\n'
              */
                );
                return code;
            }
        },
        {
            name: `${pluginName}:config`,
            apply: 'build',
            // We need to run this plugin before in order to make isLeaderPluginInstance() work
            enforce: 'pre',
            configResolved(configUnresolved) {
                // Upon the server-side build (`$ vite build --ssr`), we need to override the previous `skip` value set by the client-side build (`$ vite build`).
                skip = !(0, utils_1.viteIsSSR)(configUnresolved);
                if (skip)
                    return;
                (0, utils_1.assertUsage)(typeof configUnresolved.build.ssr !== 'string', "Setting the server build entry over the Vite configuration `build.ssr` (i.e. `--ssr path/to/entry.js`) isn't supported (because of a Vite bug), see workaround at https://github.com/brillout/vite-plugin-server-entry/issues/9#issuecomment-2027641624");
                const resolved = resolveConfig(configUnresolved, pluginConfigProvidedByLibrary);
                config = resolved.config;
                library = resolved.library;
            }
        }
    ];
}
function getServerEntryName(config) {
    const entries = (0, utils_1.normalizeRollupInput)(config.build.rollupOptions.input);
    (0, utils_1.assert)(entries[serverEntryFileNameBase_1.serverEntryFileNameBase] !== serverEntryVirtualId &&
        entries[serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative] !== serverEntryVirtualId);
    const serverEntryName = !entries[serverEntryFileNameBase_1.serverEntryFileNameBase]
        ? serverEntryFileNameBase_1.serverEntryFileNameBase
        : serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative;
    (0, utils_1.assert)(!entries[serverEntryName]);
    return serverEntryName;
}
function resolveConfig(configUnresolved, pluginConfigProvidedByLibrary) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(configUnresolved));
    const pluginConfigResolved = configUnresolved._vitePluginServerEntry ?? {
        libraries: [],
        apiVersion,
        autoImport: true,
        inject: false
    };
    setInjectConfig(pluginConfigResolved, pluginConfigProvidedByLibrary.inject);
    const library = {
        getServerProductionEntry: pluginConfigProvidedByLibrary.getServerProductionEntry,
        libraryName: pluginConfigProvidedByLibrary.libraryName,
        pluginVersion: utils_1.projectInfo.projectVersion,
        apiVersion
    };
    pluginConfigResolved.libraries.push(library);
    (0, utils_1.objectAssign)(configUnresolved, {
        _vitePluginServerEntry: pluginConfigResolved
    });
    const config = configUnresolved;
    return { config, library };
}
function applyPluginConfigProvidedByUser(config) {
    const pluginConfigResolved = config._vitePluginServerEntry;
    const pluginConfigProvidedByUser = config.vitePluginServerEntry ?? {};
    setInjectConfig(pluginConfigResolved, pluginConfigProvidedByUser.inject);
    if (pluginConfigProvidedByUser.autoImport !== undefined) {
        pluginConfigResolved.autoImport = pluginConfigProvidedByUser.autoImport;
    }
}
function setInjectConfig(pluginConfigResolved, inject) {
    if (!inject)
        return;
    if (inject === true) {
        if (!pluginConfigResolved.inject) {
            pluginConfigResolved.inject = true;
        }
        return;
    }
    if (!Array.isArray(pluginConfigResolved.inject)) {
        pluginConfigResolved.inject = [];
    }
    pluginConfigResolved.inject.push(...inject);
}
function isLeaderPluginInstance(config, library) {
    const { libraries } = config._vitePluginServerEntry;
    const pluginVersionCurrent = utils_1.projectInfo.projectVersion;
    (0, utils_1.assert)(libraries.includes(library));
    const isNotUsingNewestPluginVersion = libraries.some((lib) => {
        // Can be undefined when set by an older @brillout/vite-plugin-dist-importer version
        if (!lib.pluginVersion)
            return false;
        return isHigherVersion(lib.pluginVersion, pluginVersionCurrent);
    });
    if (isNotUsingNewestPluginVersion)
        return false;
    const librariesUsingNewestPluginVersion = libraries.filter((lib) => lib.pluginVersion === pluginVersionCurrent);
    return librariesUsingNewestPluginVersion[0] === library;
}
function getServerProductionEntryAll(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const serverProductionEntry = [
        '// Generated by https://github.com/brillout/vite-plugin-server-entry',
        ...config._vitePluginServerEntry.libraries.map((library) => {
            // Should be true because of assertApiVersions()
            (0, utils_1.assert)(getLibraryApiVersion(library) === apiVersion);
            const entryCode = (library.getServerProductionEntry ??
                // Support old `getServerProductionEntry()` name: it was previously called `getImporterCode()`.
                // TODO/api-version-bump: We'll be able to remove this next time we bump `apiVersion`.
                // @ts-expect-error
                library.getImporterCode)();
            return entryCode;
        })
    ].join('\n');
    return serverProductionEntry;
}
function writeAutoImporterFile(config, entryFileName) {
    const { distServerPathRelative, distServerPathAbsolute } = getDistServerPathRelative(config);
    const serverEntryFilePathRelative = path_1.default.posix.join(distServerPathRelative, entryFileName);
    const serverEntryFilePathAbsolute = path_1.default.posix.join(distServerPathAbsolute, entryFileName);
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)(!isAutoImportDisabled(config));
    (0, utils_1.assert)(!(0, utils_1.isYarnPnP)());
    (0, fs_1.writeFileSync)(autoImporterFilePath, [
        "exports.status = 'SET';",
        `exports.loadServerEntry = async () => { await import(${JSON.stringify(serverEntryFilePathRelative)}); };`,
        'exports.paths = {',
        `  autoImporterFilePathOriginal: ${JSON.stringify(autoImporterFilePath)},`,
        '  autoImporterFileDirActual: (() => { try { return __dirname } catch { return null } })(),',
        `  serverEntryFilePathRelative: ${JSON.stringify(serverEntryFilePathRelative)},`,
        `  serverEntryFilePathOriginal: ${JSON.stringify(serverEntryFilePathAbsolute)},`,
        `  serverEntryFilePathResolved: () => require.resolve(${JSON.stringify(serverEntryFilePathRelative)}),`,
        '};',
        ''
    ].join('\n'));
}
function clearAutoImporter(config) {
    let status;
    if (!isAutoImportDisabled(config)) {
        status = 'BUILDING';
    }
    else {
        const { inject, autoImport } = config._vitePluginServerEntry;
        if ((0, utils_1.isYarnPnP)()) {
            return;
        }
        else if (!autoImport) {
            status = 'DISABLED_BY_USER';
        }
        else {
            (0, utils_1.assert)(inject);
            status = 'DISABLED_BY_INJECT';
        }
    }
    (0, utils_1.assert)(status);
    const autoImporterContent = (0, fs_1.readFileSync)(autoImporterFilePath);
    if (autoImporterContent.includes(status))
        return;
    (0, utils_1.assert)(!(0, utils_1.isYarnPnP)());
    (0, fs_1.writeFileSync)(autoImporterFilePath, [`exports.status = '${status}';`, ''].join('\n'));
}
/** Is `semver1` higher than `semver2`?*/
function isHigherVersion(semver1, semver2) {
    const parsed1 = parseSemver(semver1);
    const parsed2 = parseSemver(semver2);
    for (let i = 0; i <= parsed1.parts.length - 1; i++) {
        if (parsed1.parts[i] !== parsed2.parts[i]) {
            return parsed1.parts[i] > parsed2.parts[i];
        }
    }
    if (parsed1.isPreRelease !== parsed2.isPreRelease) {
        return parsed1.isPreRelease;
    }
    return false;
}
function parseSemver(semver) {
    let isPreRelease = false;
    if (semver.includes('-')) {
        isPreRelease = true;
        semver = semver.split('-')[0]; // '0.2.16-commit-89bbe89' => '0.2.16'
    }
    (0, utils_1.assert)(/^[0-9\.]+$/.test(semver));
    const partsStr = semver.split('.');
    (0, utils_1.assert)(partsStr.length === 3);
    const parts = partsStr.map((n) => parseInt(n, 10));
    return { parts, isPreRelease };
}
function getDistServerPathRelative(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)((0, utils_1.isAbsolutePath)(root));
    const importerDir = getDirname();
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let { outDir } = config.build;
    // SvelteKit doesn't set config.build.outDir to a posix path
    outDir = (0, utils_1.toPosixPath)(outDir);
    if ((0, utils_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_1.assert)(!(0, utils_1.isAbsolutePath)(outDir));
    }
    const distServerPathRelative = path_1.default.posix.join(rootRelative, outDir);
    const distServerPathAbsolute = path_1.default.posix.join(root, outDir);
    (0, debugLogsBuildTime_1.debugLogsBuildtime)({
        disabled: false,
        paths: { importerDir, root, rootRelative, outDir, distServerPathRelative, distServerPathAbsolute }
    });
    return { distServerPathRelative, distServerPathAbsolute };
}
function getDirname() {
    const dirname = (0, utils_1.toPosixPath)(__dirname + (() => '')()); // trick to avoid `@vercel/ncc` to glob import
    return dirname;
}
function assertApiVersions(config, currentLibraryName) {
    const librariesNeedingUpdate = [];
    ['vitePluginDistImporter', '_vitePluginImportBuild'].forEach((key) => {
        if (key in config) {
            const dataOld = config[key];
            dataOld.libraries.forEach((lib) => {
                (0, utils_1.assert)(lib.libraryName);
                librariesNeedingUpdate.push(lib.libraryName);
            });
        }
    });
    const pluginConfigResolved = config._vitePluginServerEntry;
    pluginConfigResolved.libraries.forEach((library) => {
        const apiVersionLib = getLibraryApiVersion(library);
        if (apiVersionLib < apiVersion) {
            librariesNeedingUpdate.push(library.libraryName);
        }
        else {
            // Should be true thanks to isLeaderPluginInstance()
            (0, utils_1.assert)(apiVersionLib === apiVersion);
        }
    });
    if (librariesNeedingUpdate.length > 0) {
        const libs = (0, utils_1.joinEnglish)(librariesNeedingUpdate, 'and');
        // We purposely use `throw new Error()` instead of `assertUsage()`, in order to not confuse the user with superfluous information
        throw new Error(`Update ${libs} to its latest version and try again: ${currentLibraryName} requires a newer version of ${libs}.`);
    }
}
function getLibraryApiVersion(library) {
    // library.apiVersion can be undefined when set by an older @brillout/vite-plugin-server-entry version
    const apiVersionLib = library.apiVersion ?? 1;
    return apiVersionLib;
}
function findServerEntry(bundle) {
    const entry = (0, utils_1.findRollupBundleEntry)(serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative, bundle) ||
        (0, utils_1.findRollupBundleEntry)(serverEntryFileNameBase_1.serverEntryFileNameBase, bundle);
    (0, utils_1.assertUsage)(entry, errMsgEntryRemoved([
        //
        serverEntryFileNameBase_1.serverEntryFileNameBase,
        serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative
    ], Object.keys(bundle)));
    return entry;
}
function getInjectEntries(config) {
    (0, utils_1.assert)(config._vitePluginServerEntry.inject !== false);
    const entries = (0, utils_1.normalizeRollupInput)(config.build.rollupOptions.input);
    const injectEntryNames = config._vitePluginServerEntry.inject === true ? [indexEntryName] : config._vitePluginServerEntry.inject;
    const injectEntries = injectEntryNames
        .map((entryName) => {
        let entryFilePath = entries[entryName];
        if (!entryFilePath)
            return null;
        entryFilePath = require.resolve(entryFilePath);
        // Needs to be absolute, otherwise it won't match the `id` in `transform(id)`
        (0, utils_1.assert)(path_1.default.isAbsolute(entryFilePath));
        entryFilePath = (0, utils_1.toPosixPath)(entryFilePath);
        return entryFilePath;
    })
        .filter((e) => e !== null);
    if (injectEntries.length === 0) {
        const entryNames = Object.keys(entries);
        (0, utils_1.assertUsage)(false, errMsgEntryRemoved(injectEntryNames, entryNames));
    }
    return injectEntries;
}
function errMsgEntryRemoved(entriesMissing, entriesExisting) {
    const list = (items) => '[' + items.map((e) => `'${e}'`).join(', ') + ']';
    return [
        entriesMissing.length === 1
            ? `Cannot find build server entry '${entriesMissing[0]}'.`
            : `Cannot find build server entry, searching for:  ${list(entriesMissing)} (none of them exist, but one of these should exist).`,
        `Make sure your Vite config (or that of a Vite plugin) doesn't remove/overwrite server build entries.`,
        `(Found server entries: ${list(entriesExisting)}.)`
    ].join(' ');
}
function isAutoImportDisabled(config) {
    const { inject, autoImport } = config._vitePluginServerEntry;
    return (0, utils_1.isYarnPnP)() || !!inject || !autoImport;
}
