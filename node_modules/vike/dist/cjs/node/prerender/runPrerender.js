"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPrerenderFromAPI = runPrerenderFromAPI;
exports.runPrerenderFromCLI = runPrerenderFromCLI;
exports.runPrerenderFromAutoFullBuild = runPrerenderFromAutoFullBuild;
exports.runPrerender_forceExit = runPrerender_forceExit;
require("../runtime/page-files/setup.js");
const path_1 = __importDefault(require("path"));
const index_js_1 = require("../../shared/route/index.js");
const utils_js_1 = require("./utils.js");
const renderPageAlreadyRouted_js_1 = require("../runtime/renderPage/renderPageAlreadyRouted.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const os_1 = require("os");
const globalContext_js_1 = require("../runtime/globalContext.js");
const vite_1 = require("vite");
const getConfigVike_js_1 = require("../shared/getConfigVike.js");
const getPageFiles_js_1 = require("../../shared/getPageFiles.js");
const getPageContextRequestUrl_js_1 = require("../../shared/getPageContextRequestUrl.js");
const resolveRouteString_js_1 = require("../../shared/route/resolveRouteString.js");
const helpers_js_1 = require("../../shared/page-configs/helpers.js");
const getConfigValue_js_1 = require("../../shared/page-configs/getConfigValue.js");
const loadConfigValues_js_1 = require("../../shared/page-configs/loadConfigValues.js");
const error_page_js_1 = require("../../shared/error-page.js");
const getPageContextUrlComputed_js_1 = require("../../shared/getPageContextUrlComputed.js");
const abort_js_1 = require("../../shared/route/abort.js");
const loadUserFilesServerSide_js_1 = require("../runtime/renderPage/loadUserFilesServerSide.js");
const getHook_js_1 = require("../../shared/hooks/getHook.js");
const noRouteMatch_js_1 = require("../../shared/route/noRouteMatch.js");
const getVikeConfig_js_1 = require("../plugin/plugins/importUserCode/v1-design/getVikeConfig.js");
const logErrorHint_js_1 = require("../runtime/renderPage/logErrorHint.js");
const executeHook_js_1 = require("../../shared/hooks/executeHook.js");
const getConfigValueBuildTime_js_1 = require("../../shared/page-configs/getConfigValueBuildTime.js");
async function runPrerenderFromAPI(options = {}) {
    await runPrerender(options, 'prerender()');
    // - We purposely propagate the error to the user land, so that the error interrupts the user land. It's also, I guess, a nice-to-have that the user has control over the error.
    // - We don't use logErrorHint() because we don't have control over what happens with the error. For example, if the user land purposely swallows the error then the hint shouldn't be logged. Also, it's best if the hint is shown to the user *after* the error, but we cannot do/guarentee that.
}
async function runPrerenderFromCLI(options) {
    try {
        await runPrerender(options, '$ vike prerender');
    }
    catch (err) {
        console.error(err);
        (0, logErrorHint_js_1.logErrorHint)(err);
        process.exit(1);
    }
}
async function runPrerenderFromAutoFullBuild(options) {
    try {
        await runPrerender(options, null);
    }
    catch (err) {
        console.error(err);
        (0, logErrorHint_js_1.logErrorHint)(err);
        process.exit(1);
    }
}
async function runPrerender(options, manuallyTriggered) {
    checkOutdatedOptions(options);
    (0, globalContext_js_1.setGlobalContext_isPrerendering)();
    (0, getHook_js_1.getHook_setIsPrerenderering)();
    const logLevel = !!options.onPagePrerender ? 'warn' : 'info';
    if (logLevel === 'info') {
        console.log(`${picocolors_1.default.cyan(`vike v${utils_js_1.projectInfo.projectVersion}`)} ${picocolors_1.default.green('pre-rendering HTML...')}`);
    }
    (0, utils_js_1.handleNodeEnv_prerender)();
    await disableReactStreaming();
    const viteConfig = await (0, vite_1.resolveConfig)(options.viteConfig || {}, 'vike pre-rendering', 'production');
    assertLoadedConfig(viteConfig, options);
    const configVike = await (0, getConfigVike_js_1.getConfigVike)(viteConfig);
    const { outDirClient } = (0, utils_js_1.getOutDirs)(viteConfig);
    const { root } = viteConfig;
    const prerenderConfig = configVike.prerender;
    if (!prerenderConfig) {
        (0, utils_js_1.assert)(manuallyTriggered);
        (0, utils_js_1.assertWarning)(prerenderConfig, `You're executing ${picocolors_1.default.cyan(manuallyTriggered)} but the config ${picocolors_1.default.cyan('prerender')} isn't set to true`, {
            onlyOnce: true
        });
    }
    const { partial = false, noExtraDir = false, parallel = true } = prerenderConfig || {};
    const concurrencyLimit = (0, utils_js_1.pLimit)(parallel === false || parallel === 0 ? 1 : parallel === true || parallel === undefined ? (0, os_1.cpus)().length : parallel);
    await (0, globalContext_js_1.initGlobalContext_runPrerender)();
    const renderContext = await (0, renderPageAlreadyRouted_js_1.getRenderContext)();
    renderContext.pageFilesAll.forEach(assertExportNames);
    const prerenderContext = {};
    (0, utils_js_1.objectAssign)(prerenderContext, {
        _urlHandler: null,
        _noExtraDir: noExtraDir ?? false,
        pageContexts: [],
        pageContextInit: options.pageContextInit ?? null
    });
    const doNotPrerenderList = [];
    const vikeConfig = await (0, getVikeConfig_js_1.getVikeConfig)(viteConfig, false);
    await collectDoNoPrerenderList(renderContext, vikeConfig.pageConfigs, doNotPrerenderList, concurrencyLimit);
    await callOnBeforePrerenderStartHooks(prerenderContext, renderContext, concurrencyLimit, doNotPrerenderList);
    await handlePagesWithStaticRoutes(prerenderContext, renderContext, doNotPrerenderList, concurrencyLimit);
    await callOnPrerenderStartHook(prerenderContext, renderContext);
    const prerenderedPageContexts = {};
    let prerenderedCount = 0;
    const onComplete = async (htmlFile) => {
        prerenderedCount++;
        if (htmlFile.pageId) {
            prerenderedPageContexts[htmlFile.pageId] = htmlFile.pageContext;
        }
        await writeFiles(htmlFile, root, outDirClient, options.onPagePrerender, logLevel);
    };
    await routeAndPrerender(prerenderContext, concurrencyLimit, onComplete);
    warnContradictoryNoPrerenderList(prerenderedPageContexts, doNotPrerenderList);
    await prerender404(prerenderedPageContexts, renderContext, prerenderContext, onComplete);
    if (logLevel === 'info') {
        console.log(`${picocolors_1.default.green(`âœ“`)} ${prerenderedCount} HTML documents pre-rendered.`);
    }
    warnMissingPages(prerenderedPageContexts, doNotPrerenderList, renderContext, partial);
}
async function collectDoNoPrerenderList(renderContext, pageConfigs, doNotPrerenderList, concurrencyLimit) {
    // V1 design
    pageConfigs.forEach((pageConfig) => {
        const configName = 'prerender';
        const configValue = (0, getConfigValueBuildTime_js_1.getConfigValueBuildTime)(pageConfig, configName, 'boolean');
        if (configValue?.value === false) {
            const configValueFilePathToShowToUser = (0, helpers_js_1.getConfigValueFilePathToShowToUser)(configValue.definedAtData);
            (0, utils_js_1.assert)(configValueFilePathToShowToUser);
            doNotPrerenderList.push({
                pageId: pageConfig.pageId,
                setByConfigName: 'prerender',
                setByConfigValue: false,
                setByConfigFile: configValueFilePathToShowToUser
            });
        }
    });
    // Old design
    // TODO/v1-release: remove
    await Promise.all(renderContext.pageFilesAll
        .filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('doNotPrerender'))
            return false;
        (0, utils_js_1.assertUsage)(p.fileType !== '.page.client', `${p.filePath} (which is a \`.page.client.js\` file) has \`export { doNotPrerender }\` but it is only allowed in \`.page.server.js\` or \`.page.js\` files`);
        return true;
    })
        .map((p) => concurrencyLimit(async () => {
        (0, utils_js_1.assert)(p.loadFile);
        await p.loadFile();
    })));
    renderContext.allPageIds.forEach((pageId) => {
        const pageFilesServerSide = (0, getPageFiles_js_1.getPageFilesServerSide)(renderContext.pageFilesAll, pageId);
        for (const p of pageFilesServerSide) {
            if (!p.exportNames?.includes('doNotPrerender'))
                continue;
            const { fileExports } = p;
            (0, utils_js_1.assert)(fileExports);
            (0, utils_js_1.assert)((0, utils_js_1.hasProp)(fileExports, 'doNotPrerender'));
            const { doNotPrerender } = fileExports;
            (0, utils_js_1.assertUsage)(doNotPrerender === true || doNotPrerender === false, `The \`export { doNotPrerender }\` value of ${p.filePath} should be \`true\` or \`false\``);
            if (!doNotPrerender) {
                // Do pre-render `pageId`
                return;
            }
            else {
                // Don't pre-render `pageId`
                doNotPrerenderList.push({
                    pageId,
                    setByConfigFile: p.filePath,
                    setByConfigName: 'doNotPrerender',
                    setByConfigValue: doNotPrerender
                });
            }
        }
    });
}
function assertExportNames(pageFile) {
    const { exportNames, fileType } = pageFile;
    (0, utils_js_1.assert)(exportNames || fileType === '.page.route' || fileType === '.css', pageFile.filePath);
}
async function callOnBeforePrerenderStartHooks(prerenderContext, renderContext, concurrencyLimit, doNotPrerenderList) {
    const onBeforePrerenderStartHooks = [];
    // V1 design
    await Promise.all(renderContext.pageConfigs.map((pageConfig) => concurrencyLimit(async () => {
        const hookName = 'onBeforePrerenderStart';
        const pageConfigLoaded = await (0, loadConfigValues_js_1.loadConfigValues)(pageConfig, false);
        const hook = (0, getHook_js_1.getHookFromPageConfig)(pageConfigLoaded, hookName);
        if (!hook)
            return;
        const { hookFn, hookFilePath, hookTimeout } = hook;
        onBeforePrerenderStartHooks.push({
            hookFn,
            hookName: 'onBeforePrerenderStart',
            hookFilePath,
            pageId: pageConfig.pageId,
            hookTimeout
        });
    })));
    // 0.4 design
    await Promise.all(renderContext.pageFilesAll
        .filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('prerender'))
            return false;
        (0, utils_js_1.assertUsage)(p.fileType === '.page.server', `${p.filePath} (which is a \`${p.fileType}.js\` file) has \`export { prerender }\` but it is only allowed in \`.page.server.js\` files`);
        return true;
    })
        .map((p) => concurrencyLimit(async () => {
        await p.loadFile?.();
        const hookFn = p.fileExports?.prerender;
        if (!hookFn)
            return;
        (0, utils_js_1.assertUsage)((0, utils_js_1.isCallable)(hookFn), `\`export { prerender }\` of ${p.filePath} should be a function.`);
        const hookFilePath = p.filePath;
        (0, utils_js_1.assert)(hookFilePath);
        onBeforePrerenderStartHooks.push({
            hookFn,
            hookName: 'prerender',
            hookFilePath,
            pageId: p.pageId,
            hookTimeout: (0, getHook_js_1.getHookTimeoutDefault)('onBeforePrerenderStart')
        });
    })));
    await Promise.all(onBeforePrerenderStartHooks.map(({ hookFn, hookName, hookFilePath, pageId, hookTimeout }) => concurrencyLimit(async () => {
        if (doNotPrerenderList.find((p) => p.pageId === pageId)) {
            return;
        }
        const prerenderResult = await (0, executeHook_js_1.executeHook)(() => hookFn(), { hookName, hookFilePath, hookTimeout }, null);
        const result = normalizeOnPrerenderHookResult(prerenderResult, hookFilePath, hookName);
        result.forEach(({ url, pageContext }) => {
            {
                const pageContextFound = prerenderContext.pageContexts.find((pageContext) => isSameUrl(pageContext.urlOriginal, url));
                if (pageContextFound) {
                    (0, utils_js_1.assert)(pageContextFound._providedByHook);
                    const providedTwice = hookFilePath === pageContextFound._providedByHook.hookFilePath
                        ? `twice by the ${hookName}() hook (${hookFilePath})`
                        : `twice: by the ${hookName}() hook (${hookFilePath}) as well as by the hook ${pageContextFound._providedByHook.hookFilePath}() (${pageContextFound._providedByHook.hookName})`;
                    (0, utils_js_1.assertUsage)(false, `URL ${picocolors_1.default.cyan(url)} provided ${providedTwice}. Make sure to provide the URL only once instead.`);
                }
            }
            const pageContextNew = createPageContext(url, renderContext, prerenderContext);
            (0, utils_js_1.objectAssign)(pageContextNew, {
                _providedByHook: {
                    hookFilePath,
                    hookName
                }
            });
            prerenderContext.pageContexts.push(pageContextNew);
            if (pageContext) {
                (0, utils_js_1.objectAssign)(pageContextNew, {
                    _pageContextAlreadyProvidedByOnPrerenderHook: true
                });
                (0, utils_js_1.objectAssign)(pageContextNew, pageContext);
            }
        });
    })));
}
async function handlePagesWithStaticRoutes(prerenderContext, renderContext, doNotPrerenderList, concurrencyLimit) {
    // Pre-render pages with a static route
    await Promise.all(renderContext.pageRoutes.map((pageRoute) => concurrencyLimit(async () => {
        const { pageId } = pageRoute;
        if (doNotPrerenderList.find((p) => p.pageId === pageId)) {
            return;
        }
        let urlOriginal;
        if (!('routeString' in pageRoute)) {
            // Abort since the page's route is a Route Function
            (0, utils_js_1.assert)(pageRoute.routeType === 'FUNCTION');
            return;
        }
        else {
            const url = (0, resolveRouteString_js_1.getUrlFromRouteString)(pageRoute.routeString);
            if (!url) {
                // Abort since no URL can be deduced from a parameterized Route String
                return;
            }
            urlOriginal = url;
        }
        (0, utils_js_1.assert)(urlOriginal.startsWith('/'));
        // Already included in a onBeforePrerenderStart() hook
        if (prerenderContext.pageContexts.find((pageContext) => isSameUrl(pageContext.urlOriginal, urlOriginal))) {
            return;
        }
        const routeParams = {};
        const pageContext = createPageContext(urlOriginal, renderContext, prerenderContext);
        (0, utils_js_1.objectAssign)(pageContext, {
            _providedByHook: null,
            routeParams,
            pageId: pageId,
            _debugRouteMatches: [
                {
                    pageId,
                    routeType: pageRoute.routeType,
                    routeString: urlOriginal,
                    routeParams
                }
            ]
        });
        (0, utils_js_1.objectAssign)(pageContext, await (0, loadUserFilesServerSide_js_1.loadUserFilesServerSide)(pageContext));
        prerenderContext.pageContexts.push(pageContext);
    })));
}
function createPageContext(urlOriginal, renderContext, prerenderContext) {
    const pageContext = {
        _urlHandler: null,
        _urlRewrite: null,
        _noExtraDir: prerenderContext._noExtraDir,
        _prerenderContext: prerenderContext
    };
    const pageContextInit = {
        urlOriginal
    };
    (0, utils_js_1.objectAssign)(pageContextInit, prerenderContext.pageContextInit);
    {
        const pageContextInitEnhanced = (0, renderPageAlreadyRouted_js_1.getPageContextInitEnhanced)(pageContextInit, renderContext);
        (0, utils_js_1.objectAssign)(pageContext, pageContextInitEnhanced);
    }
    return pageContext;
}
async function callOnPrerenderStartHook(prerenderContext, renderContext) {
    let onPrerenderStartHook;
    // V1 design
    if (renderContext.pageConfigs.length > 0) {
        const hookName = 'onPrerenderStart';
        const hook = (0, getHook_js_1.getHookFromPageConfigGlobal)(renderContext.pageConfigGlobal, hookName);
        if (hook) {
            (0, utils_js_1.assert)(hook.hookName === 'onPrerenderStart');
            onPrerenderStartHook = {
                ...hook,
                // Make TypeScript happy
                hookName
            };
        }
    }
    // Old design
    // TODO/v1-release: remove
    if (renderContext.pageConfigs.length === 0) {
        const hookTimeout = (0, getHook_js_1.getHookTimeoutDefault)('onBeforePrerender');
        const pageFilesWithOnBeforePrerenderHook = renderContext.pageFilesAll.filter((p) => {
            assertExportNames(p);
            if (!p.exportNames?.includes('onBeforePrerender'))
                return false;
            (0, utils_js_1.assertUsage)(p.fileType !== '.page.client', `${p.filePath} (which is a \`.page.client.js\` file) has \`export { onBeforePrerender }\` but it is only allowed in \`.page.server.js\` or \`.page.js\` files`);
            (0, utils_js_1.assertUsage)(p.isDefaultPageFile, `${p.filePath} has \`export { onBeforePrerender }\` but it is only allowed in \`_defaut.page.\` files`);
            return true;
        });
        if (pageFilesWithOnBeforePrerenderHook.length === 0) {
            return;
        }
        (0, utils_js_1.assertUsage)(pageFilesWithOnBeforePrerenderHook.length === 1, 'There can be only one `onBeforePrerender()` hook. If you need to be able to define several, open a new GitHub issue.');
        await Promise.all(pageFilesWithOnBeforePrerenderHook.map((p) => p.loadFile?.()));
        const hooks = pageFilesWithOnBeforePrerenderHook.map((p) => {
            (0, utils_js_1.assert)(p.fileExports);
            const { onBeforePrerender } = p.fileExports;
            (0, utils_js_1.assert)(onBeforePrerender);
            const hookFilePath = p.filePath;
            return { hookFilePath, onBeforePrerender };
        });
        (0, utils_js_1.assert)(hooks.length === 1);
        const hook = hooks[0];
        onPrerenderStartHook = {
            hookFn: hook.onBeforePrerender,
            hookFilePath: hook.hookFilePath,
            hookName: 'onBeforePrerender',
            hookTimeout
        };
    }
    if (!onPrerenderStartHook) {
        return;
    }
    const msgPrefix = `The ${onPrerenderStartHook.hookName}() hook defined by ${onPrerenderStartHook.hookFilePath}`;
    const { hookFn, hookFilePath, hookName } = onPrerenderStartHook;
    (0, utils_js_1.assertUsage)((0, utils_js_1.isCallable)(hookFn), `${msgPrefix} should be a function.`);
    prerenderContext.pageContexts.forEach((pageContext) => {
        Object.defineProperty(pageContext, 'url', {
            // TODO/v1-release: remove warning
            get() {
                (0, utils_js_1.assertWarning)(false, msgPrefix +
                    ' uses pageContext.url but it should use pageContext.urlOriginal instead, see https://vike.dev/migration/0.4.23', { showStackTrace: true, onlyOnce: true });
                return pageContext.urlOriginal;
            },
            enumerable: false,
            configurable: true
        });
        (0, utils_js_1.assert)((0, utils_js_1.isPropertyGetter)(pageContext, 'url'));
        (0, utils_js_1.assert)(pageContext.urlOriginal);
        pageContext._urlOriginalBeforeHook = pageContext.urlOriginal;
    });
    const docLink = 'https://vike.dev/i18n#pre-rendering';
    // Set `enumerable` to `false` to avoid computed URL properties from being iterated & copied in onPrerenderStart() hook, e.g. /examples/i18n/
    const { restoreEnumerable, addPageContextComputedUrl } = makePageContextComputedUrlNonEnumerable(prerenderContext.pageContexts);
    let result = await (0, executeHook_js_1.executeHook)(() => hookFn({
        pageContexts: prerenderContext.pageContexts,
        // TODO/v1-release: remove warning
        get prerenderPageContexts() {
            (0, utils_js_1.assertWarning)(false, `prerenderPageContexts has been renamed pageContexts, see ${docLink}`, {
                showStackTrace: true,
                onlyOnce: true
            });
            return prerenderContext.pageContexts;
        }
    }), onPrerenderStartHook, null);
    restoreEnumerable();
    if (result === null || result === undefined) {
        return;
    }
    const errPrefix = `The ${hookName}() hook exported by ${hookFilePath}`;
    const rightUsage = `${errPrefix} should return ${picocolors_1.default.cyan('null')}, ${picocolors_1.default.cyan('undefined')}, or ${picocolors_1.default.cyan('{ prerenderContext: { pageContexts } }')}`;
    // TODO/v1-release: remove
    if ((0, utils_js_1.hasProp)(result, 'globalContext')) {
        (0, utils_js_1.assertUsage)((0, utils_js_1.isObjectWithKeys)(result, ['globalContext']) &&
            (0, utils_js_1.hasProp)(result, 'globalContext', 'object') &&
            (0, utils_js_1.hasProp)(result.globalContext, 'prerenderPageContexts', 'array'), rightUsage);
        (0, utils_js_1.assertWarning)(false, `${errPrefix} returns ${picocolors_1.default.cyan('{ globalContext: { prerenderPageContexts } }')} but the return value has been renamed to ${picocolors_1.default.cyan('{ prerenderContext: { pageContexts } }')}, see ${docLink}`, { onlyOnce: true });
        result = {
            prerenderContext: {
                pageContexts: result.globalContext.prerenderPageContexts
            }
        };
    }
    (0, utils_js_1.assertUsage)((0, utils_js_1.isObjectWithKeys)(result, ['prerenderContext']) &&
        (0, utils_js_1.hasProp)(result, 'prerenderContext', 'object') &&
        (0, utils_js_1.hasProp)(result.prerenderContext, 'pageContexts', 'array'), rightUsage);
    prerenderContext.pageContexts = result.prerenderContext.pageContexts;
    prerenderContext.pageContexts.forEach((pageContext) => {
        // TODO/v1-release: remove
        if (pageContext.url && !(0, utils_js_1.isPropertyGetter)(pageContext, 'url')) {
            (0, utils_js_1.assertWarning)(false, msgPrefix +
                ' provided pageContext.url but it should provide pageContext.urlOriginal instead, see https://vike.dev/migration/0.4.23', { onlyOnce: true });
            pageContext.urlOriginal = pageContext.url;
        }
        delete pageContext.url;
    });
    prerenderContext.pageContexts.forEach((pageContext) => {
        if (pageContext.urlOriginal !== pageContext._urlOriginalBeforeHook) {
            pageContext._urlOriginalModifiedByHook = {
                hookFilePath,
                hookName
            };
        }
    });
    addPageContextComputedUrl(prerenderContext.pageContexts);
}
async function routeAndPrerender(prerenderContext, concurrencyLimit, onComplete) {
    const globalContext = (0, globalContext_js_1.getGlobalContext)();
    (0, utils_js_1.assert)(globalContext.isPrerendering);
    // Route all URLs
    await Promise.all(prerenderContext.pageContexts.map((pageContext) => concurrencyLimit(async () => {
        const { urlOriginal } = pageContext;
        (0, utils_js_1.assert)(urlOriginal);
        const pageContextFromRoute = await (0, index_js_1.route)(pageContext);
        (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContextFromRoute, 'pageId', 'null') || (0, utils_js_1.hasProp)(pageContextFromRoute, 'pageId', 'string'));
        if (pageContextFromRoute.pageId === null) {
            let hookName;
            let hookFilePath;
            if (pageContext._providedByHook) {
                hookName = pageContext._providedByHook.hookName;
                hookFilePath = pageContext._providedByHook.hookFilePath;
            }
            else if (pageContext._urlOriginalModifiedByHook) {
                hookName = pageContext._urlOriginalModifiedByHook.hookName;
                hookFilePath = pageContext._urlOriginalModifiedByHook.hookFilePath;
            }
            if (hookName) {
                (0, utils_js_1.assert)(hookFilePath);
                (0, utils_js_1.assertUsage)(false, `The ${hookName}() hook defined by ${hookFilePath} returns a URL ${picocolors_1.default.cyan(urlOriginal)} that ${noRouteMatch_js_1.noRouteMatch}. Make sure that the URLs returned by ${hookName}() always match the route of a page.`);
            }
            else {
                // `prerenderHookFile` is `null` when the URL was deduced by the Filesytem Routing of `.page.js` files. The `onBeforeRoute()` can override Filesystem Routing; it is therefore expected that the deduced URL may not match any page.
                (0, utils_js_1.assert)(pageContextFromRoute._routingProvidedByOnBeforeRouteHook);
                // Abort since the URL doesn't correspond to any page
                return;
            }
        }
        (0, utils_js_1.assert)(pageContextFromRoute.pageId);
        (0, utils_js_1.objectAssign)(pageContext, pageContextFromRoute);
        const { pageId: pageId } = pageContext;
        (0, utils_js_1.objectAssign)(pageContext, await (0, loadUserFilesServerSide_js_1.loadUserFilesServerSide)(pageContext));
        let usesClientRouter;
        {
            if (pageContext._pageConfigs.length > 0) {
                const pageConfig = pageContext._pageConfigs.find((p) => p.pageId === pageId);
                (0, utils_js_1.assert)(pageConfig);
                usesClientRouter = (0, getConfigValue_js_1.getConfigValueRuntime)(pageConfig, 'clientRouting', 'boolean')?.value ?? false;
            }
            else {
                usesClientRouter = globalContext.pluginManifest.usesClientRouter;
            }
        }
        (0, utils_js_1.objectAssign)(pageContext, {
            is404: null,
            _httpRequestId: null,
            _usesClientRouter: usesClientRouter
        });
        let res;
        try {
            res = await (0, renderPageAlreadyRouted_js_1.prerenderPage)(pageContext);
        }
        catch (err) {
            assertIsNotAbort(err, picocolors_1.default.cyan(pageContext.urlOriginal));
            throw err;
        }
        const { documentHtml, pageContextSerialized } = res;
        await onComplete({
            urlOriginal,
            pageContext,
            htmlString: documentHtml,
            pageContextSerialized,
            doNotCreateExtraDirectory: prerenderContext._noExtraDir,
            pageId
        });
    })));
}
function warnContradictoryNoPrerenderList(prerenderedPageContexts, doNotPrerenderList) {
    Object.entries(prerenderedPageContexts).forEach(([pageId, pageContext]) => {
        const doNotPrerenderListEntry = doNotPrerenderList.find((p) => p.pageId === pageId);
        const { urlOriginal, _providedByHook: providedByHook } = pageContext;
        {
            const isContradictory = !!doNotPrerenderListEntry && providedByHook;
            if (!isContradictory)
                return;
        }
        const { setByConfigName, setByConfigValue, setByConfigFile } = doNotPrerenderListEntry;
        (0, utils_js_1.assertWarning)(false, `The ${providedByHook.hookName}() hook defined by ${providedByHook.hookFilePath} returns the URL ${picocolors_1.default.cyan(urlOriginal)}, while ${setByConfigFile} sets the config ${picocolors_1.default.cyan(setByConfigName)} to ${picocolors_1.default.cyan(String(setByConfigValue))}. This is contradictory: either don't set the config ${picocolors_1.default.cyan(setByConfigName)} to ${picocolors_1.default.cyan(String(setByConfigValue))} or remove the URL ${picocolors_1.default.cyan(urlOriginal)} from the list of URLs to be pre-rendered.`, { onlyOnce: true });
    });
}
function warnMissingPages(prerenderedPageContexts, doNotPrerenderList, renderContext, partial) {
    const isV1 = renderContext.pageConfigs.length > 0;
    const hookName = isV1 ? 'onBeforePrerenderStart' : 'prerender';
    /* TODO/after-v1-design-release: document setting `prerender: false` as an alternative to using prerender.partial (both in the warnings and the docs)
    const optOutName = isV1 ? 'prerender' : 'doNotPrerender'
    const msgAddendum = `Explicitly opt-out by setting the config ${optOutName} to ${isV1 ? 'false' : 'true'} or use the option prerender.partial`
    */
    renderContext.allPageIds
        .filter((pageId) => !prerenderedPageContexts[pageId])
        .filter((pageId) => !doNotPrerenderList.find((p) => p.pageId === pageId))
        .filter((pageId) => !(0, error_page_js_1.isErrorPage)(pageId, renderContext.pageConfigs))
        .forEach((pageId) => {
        const pageAt = isV1 ? pageId : `\`${pageId}.page.*\``;
        (0, utils_js_1.assertWarning)(partial, `Cannot pre-render page ${pageAt} because it has a non-static route, while no ${hookName}() hook returned any URL matching the page's route. You need to use a ${hookName}() hook (https://vike.dev/${hookName}) providing a list of URLs for ${pageAt} that should be pre-rendered. If you don't want to pre-render ${pageAt} then use the option prerender.partial (https://vike.dev/prerender#partial) to suppress this warning.`, { onlyOnce: true });
    });
}
async function prerender404(prerenderedPageContexts, renderContext, prerenderContext, onComplete) {
    if (!Object.values(prerenderedPageContexts).find(({ urlOriginal }) => urlOriginal === '/404')) {
        let result;
        try {
            result = await (0, renderPageAlreadyRouted_js_1.prerender404Page)(renderContext, prerenderContext.pageContextInit);
        }
        catch (err) {
            assertIsNotAbort(err, 'the 404 page');
            throw err;
        }
        if (result) {
            const urlOriginal = '/404';
            const { documentHtml, pageContext } = result;
            await onComplete({
                urlOriginal,
                pageContext,
                htmlString: documentHtml,
                pageContextSerialized: null,
                doNotCreateExtraDirectory: true,
                pageId: null
            });
        }
    }
}
async function writeFiles({ urlOriginal, pageContext, htmlString, pageContextSerialized, doNotCreateExtraDirectory }, root, outDirClient, onPagePrerender, logLevel) {
    (0, utils_js_1.assert)(urlOriginal.startsWith('/'));
    const writeJobs = [
        write(urlOriginal, pageContext, '.html', htmlString, root, outDirClient, doNotCreateExtraDirectory, onPagePrerender, logLevel)
    ];
    if (pageContextSerialized !== null) {
        writeJobs.push(write(urlOriginal, pageContext, '.pageContext.json', pageContextSerialized, root, outDirClient, doNotCreateExtraDirectory, onPagePrerender, logLevel));
    }
    await Promise.all(writeJobs);
}
async function write(urlOriginal, pageContext, fileExtension, fileContent, root, outDirClient, doNotCreateExtraDirectory, onPagePrerender, logLevel) {
    let fileUrl;
    if (fileExtension === '.html') {
        fileUrl = (0, utils_js_1.urlToFile)(urlOriginal, '.html', doNotCreateExtraDirectory);
    }
    else {
        fileUrl = (0, getPageContextRequestUrl_js_1.getPageContextRequestUrl)(urlOriginal);
    }
    (0, utils_js_1.assertPosixPath)(fileUrl);
    (0, utils_js_1.assert)(fileUrl.startsWith('/'));
    const filePathRelative = fileUrl.slice(1);
    (0, utils_js_1.assert)(!filePathRelative.startsWith('/'), 
    // Let's remove this debug info after we add a assertUsage() avoiding https://github.com/vikejs/vike/issues/1929
    { urlOriginal, fileUrl });
    (0, utils_js_1.assertPosixPath)(outDirClient);
    (0, utils_js_1.assertPosixPath)(filePathRelative);
    const filePath = path_1.default.posix.join(outDirClient, filePathRelative);
    if (onPagePrerender) {
        const prerenderPageContext = {};
        (0, utils_js_1.objectAssign)(prerenderPageContext, pageContext);
        (0, utils_js_1.objectAssign)(prerenderPageContext, {
            _prerenderResult: {
                filePath,
                fileContent
            }
        });
        await onPagePrerender(prerenderPageContext);
    }
    else {
        const { promises } = await Promise.resolve().then(() => __importStar(require('fs')));
        const { writeFile, mkdir } = promises;
        await mkdir(path_1.default.posix.dirname(filePath), { recursive: true });
        await writeFile(filePath, fileContent);
        if (logLevel === 'info') {
            (0, utils_js_1.assertPosixPath)(root);
            (0, utils_js_1.assertPosixPath)(outDirClient);
            let outDirClientRelative = path_1.default.posix.relative(root, outDirClient);
            if (!outDirClientRelative.endsWith('/')) {
                outDirClientRelative = outDirClientRelative + '/';
            }
            console.log(`${picocolors_1.default.dim(outDirClientRelative)}${picocolors_1.default.blue(filePathRelative)}`);
        }
    }
}
function normalizeOnPrerenderHookResult(prerenderResult, prerenderHookFile, hookName) {
    if ((0, utils_js_1.isArray)(prerenderResult)) {
        return prerenderResult.map(normalize);
    }
    else {
        return [normalize(prerenderResult)];
    }
    function normalize(prerenderElement) {
        if (typeof prerenderElement === 'string') {
            prerenderElement = { url: prerenderElement, pageContext: null };
        }
        const errMsg1 = `The ${hookName}() hook defined by ${prerenderHookFile} returned`;
        const errMsg2 = `${errMsg1} an invalid value`;
        const errHint = `Make sure your ${hookName}() hook returns an object ${picocolors_1.default.cyan('{ url, pageContext }')} or an array of such objects.`;
        (0, utils_js_1.assertUsage)((0, utils_js_1.isPlainObject)(prerenderElement), `${errMsg2}. ${errHint}`);
        (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(prerenderElement, 'url'), `${errMsg2}: ${picocolors_1.default.cyan('url')} is missing. ${errHint}`);
        (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(prerenderElement, 'url', 'string'), `${errMsg2}: ${picocolors_1.default.cyan('url')} should be a string (but ${picocolors_1.default.cyan(`typeof url === "${typeof prerenderElement.url}"`)}).`);
        (0, utils_js_1.assertUsage)(prerenderElement.url.startsWith('/'), `${errMsg1} a URL with an invalid value ${picocolors_1.default.cyan(prerenderElement.url)} which doesn't start with ${picocolors_1.default.cyan('/')}. Make sure each URL starts with ${picocolors_1.default.cyan('/')}.`);
        Object.keys(prerenderElement).forEach((key) => {
            (0, utils_js_1.assertUsage)(key === 'url' || key === 'pageContext', `${errMsg2}: unexpected object key ${picocolors_1.default.cyan(key)}. ${errHint}`);
        });
        if (!(0, utils_js_1.hasProp)(prerenderElement, 'pageContext')) {
            prerenderElement.pageContext = null;
        }
        else if (!(0, utils_js_1.hasProp)(prerenderElement, 'pageContext', 'null')) {
            (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(prerenderElement, 'pageContext', 'object'), `${errMsg1} an invalid ${picocolors_1.default.cyan('pageContext')} value: make sure ${picocolors_1.default.cyan('pageContext')} is an object.`);
            (0, utils_js_1.assertUsage)((0, utils_js_1.isPlainObject)(prerenderElement.pageContext), `${errMsg1} an invalid ${picocolors_1.default.cyan('pageContext')} object: make sure ${picocolors_1.default.cyan('pageContext')} is a plain JavaScript object.`);
        }
        (0, utils_js_1.assert)((0, utils_js_1.hasProp)(prerenderElement, 'pageContext', 'object') || (0, utils_js_1.hasProp)(prerenderElement, 'pageContext', 'null'));
        return prerenderElement;
    }
}
// TODO/v1-release: remove
function checkOutdatedOptions(options) {
    (0, utils_js_1.assertUsage)(options.root === undefined, 'Option `prerender({ root })` deprecated: set `prerender({ viteConfig: { root }})` instead.', { showStackTrace: true });
    (0, utils_js_1.assertUsage)(options.configFile === undefined, 'Option `prerender({ configFile })` deprecated: set `prerender({ viteConfig: { configFile }})` instead.', { showStackTrace: true });
    ['noExtraDir', 'partial', 'parallel'].forEach((prop) => {
        (0, utils_js_1.assertUsage)(options[prop] === undefined, `[prerender()] Option ${picocolors_1.default.cyan(prop)} is deprecated. Define ${picocolors_1.default.cyan(prop)} in vite.config.js instead. See https://vike.dev/prerender`, { showStackTrace: true });
    });
    ['base', 'outDir'].forEach((prop) => {
        (0, utils_js_1.assertWarning)(options[prop] === undefined, `[prerender()] Option ${picocolors_1.default.cyan(prop)} is outdated and has no effect (vike now automatically determines ${picocolors_1.default.cyan(prop)})`, {
            showStackTrace: true,
            onlyOnce: true
        });
    });
}
async function disableReactStreaming() {
    let mod;
    try {
        mod = await Promise.resolve().then(() => __importStar(require('react-streaming/server')));
    }
    catch {
        return;
    }
    const { disable } = mod;
    disable();
}
function assertLoadedConfig(viteConfig, options) {
    if (viteConfig.plugins.some((p) => p.name.startsWith('vike'))) {
        return;
    }
    const { configFile } = viteConfig;
    if (configFile) {
        (0, utils_js_1.assertUsage)(false, `${configFile} doesn't install the vike plugin`);
    }
    else {
        if (!options.viteConfig) {
            (0, utils_js_1.assertUsage)(false, `[prerender()] No vite.config.js file found at ${process.cwd()}. Use the option ${picocolors_1.default.cyan('prerender({ viteConfig })')}.`, { showStackTrace: true });
        }
        else {
            (0, utils_js_1.assertUsage)(false, `[prerender()] The Vite config ${picocolors_1.default.cyan('prerender({ viteConfig })')} is missing the vike plugin.`, {
                showStackTrace: true
            });
        }
    }
}
function isSameUrl(url1, url2) {
    return normalizeUrl(url1) === normalizeUrl(url2);
}
function normalizeUrl(url) {
    return '/' + url.split('/').filter(Boolean).join('/');
}
function runPrerender_forceExit() {
    // Force exit; known situations where pre-rendering is hanging:
    //  - https://github.com/vikejs/vike/discussions/774#discussioncomment-5584551
    //  - https://github.com/vikejs/vike/issues/807#issuecomment-1519010902
    process.exit(0);
    /* I guess there is no need to tell the user about it? Let's see if a user complains.
     * I don't known whether there is a way to call process.exit(0) only if needed, thus I'm not sure if there is a way to conditionally show a assertInfo().
    assertInfo(false, "Pre-rendering was forced exit. (Didn't gracefully exit because the event queue isn't empty. This is usally fine, see ...", { onlyOnce: false })
    */
}
function assertIsNotAbort(err, urlOr404) {
    if (!(0, abort_js_1.isAbortError)(err))
        return;
    const pageContextAbort = err._pageContextAbort;
    const hookLoc = (0, executeHook_js_1.isUserHookError)(err);
    (0, utils_js_1.assert)(hookLoc);
    const thrownBy = ` by ${picocolors_1.default.cyan(`${hookLoc.hookName}()`)} hook defined at ${hookLoc.hookFilePath}`;
    const abortCaller = pageContextAbort._abortCaller;
    (0, utils_js_1.assert)(abortCaller);
    const abortCall = pageContextAbort._abortCall;
    (0, utils_js_1.assert)(abortCall);
    (0, utils_js_1.assertUsage)(false, `${picocolors_1.default.cyan(abortCall)} thrown${thrownBy} while pre-rendering ${urlOr404} but ${picocolors_1.default.cyan(abortCaller)} isn't supported for pre-rendered pages`);
}
function makePageContextComputedUrlNonEnumerable(pageContexts) {
    change(false);
    return { restoreEnumerable, addPageContextComputedUrl };
    function restoreEnumerable() {
        change(true);
    }
    function addPageContextComputedUrl(pageContexts) {
        // Add URL computed props to the user-generated pageContext copies
        pageContexts.forEach((pageContext) => {
            const pageContextUrlComputed = (0, getPageContextUrlComputed_js_1.getPageContextUrlComputed)(pageContext);
            (0, utils_js_1.objectAssign)(pageContext, pageContextUrlComputed);
        });
    }
    function change(enumerable) {
        pageContexts.forEach((pageContext) => {
            (0, utils_js_1.changeEnumerable)(pageContext, 'urlPathname', enumerable);
            (0, utils_js_1.changeEnumerable)(pageContext, 'urlParsed', enumerable);
        });
    }
}
