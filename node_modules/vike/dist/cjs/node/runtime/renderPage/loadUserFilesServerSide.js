"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadUserFilesServerSide = loadUserFilesServerSide;
const getPageFiles_js_1 = require("../../../shared/getPageFiles.js");
const analyzePageClientSide_js_1 = require("../../../shared/getPageFiles/analyzePageClientSide.js");
const utils_js_1 = require("../utils.js");
const getPageAssets_js_1 = require("./getPageAssets.js");
const debugPageFiles_js_1 = require("./debugPageFiles.js");
const findPageConfig_js_1 = require("../../../shared/page-configs/findPageConfig.js");
const analyzePage_js_1 = require("./analyzePage.js");
const globalContext_js_1 = require("../globalContext.js");
const loadConfigValues_js_1 = require("../../../shared/page-configs/loadConfigValues.js");
async function loadUserFilesServerSide(pageContext) {
    const pageConfig = (0, findPageConfig_js_1.findPageConfig)(pageContext._pageConfigs, pageContext.pageId); // Make pageConfig globally available as pageContext._pageConfig?
    const [{ pageFilesLoaded, pageContextExports }] = await Promise.all([
        loadPageUserFiles(pageContext._pageFilesAll, pageConfig, pageContext.pageId, !(0, globalContext_js_1.getGlobalContext)().isProduction),
        (0, analyzePageClientSide_js_1.analyzePageClientSideInit)(pageContext._pageFilesAll, pageContext.pageId, { sharedPageFilesAlreadyLoaded: true })
    ]);
    const { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide } = (0, analyzePage_js_1.analyzePage)(pageContext._pageFilesAll, pageConfig, pageContext.pageId);
    const isV1Design = !!pageConfig;
    const passToClient = [];
    const errMsg = ' should be an array of strings.';
    if (!isV1Design) {
        pageContextExports.exportsAll.passToClient?.forEach((e) => {
            (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(e, 'exportValue', 'string[]'), `${e.exportSource}${errMsg}`);
            passToClient.push(...e.exportValue);
        });
    }
    else {
        pageContextExports.configEntries.passToClient?.forEach((e) => {
            const { configValue } = e;
            (0, utils_js_1.assert)((0, utils_js_1.isArray)(configValue));
            const vals = configValue.flat(1);
            // TODO: improve error message by using (upcoming) new data structure instead of configEntries
            (0, utils_js_1.assertUsage)((0, utils_js_1.isArrayOfStrings)(vals), `${e.configDefinedAt}${errMsg}`);
            passToClient.push(...vals);
        });
    }
    const pageContextAddendum = {};
    (0, utils_js_1.objectAssign)(pageContextAddendum, pageContextExports);
    (0, utils_js_1.objectAssign)(pageContextAddendum, {
        Page: pageContextExports.exports.Page,
        _isHtmlOnly: isHtmlOnly,
        _passToClient: passToClient,
        _pageFilePathsLoaded: pageFilesLoaded.map((p) => p.filePath)
    });
    (0, utils_js_1.objectAssign)(pageContextAddendum, {
        __getPageAssets: async () => {
            if ('_pageAssets' in pageContext) {
                return pageContext._pageAssets;
            }
            else {
                const pageAssets = await (0, getPageAssets_js_1.getPageAssets)(pageContext, clientDependencies, clientEntries);
                (0, utils_js_1.objectAssign)(pageContext, { _pageAssets: pageAssets });
                return pageContext._pageAssets;
            }
        }
    });
    // TODO/v1-release: remove
    Object.assign(pageContextAddendum, {
        _getPageAssets: async () => {
            (0, utils_js_1.assertWarning)(false, 'pageContext._getPageAssets() deprecated, see https://vike.dev/preloading', {
                onlyOnce: true,
                showStackTrace: true
            });
            const pageAssetsOldFormat = [];
            (await pageContextAddendum.__getPageAssets()).forEach((p) => {
                if (p.assetType === 'script' && p.isEntry) {
                    pageAssetsOldFormat.push({
                        src: p.src,
                        preloadType: null,
                        assetType: 'script',
                        mediaType: p.mediaType
                    });
                }
                pageAssetsOldFormat.push({
                    src: p.src,
                    preloadType: p.assetType,
                    assetType: p.assetType === 'style' ? 'style' : 'preload',
                    mediaType: p.mediaType
                });
            });
            return pageAssetsOldFormat;
        }
    });
    {
        (0, debugPageFiles_js_1.debugPageFiles)({
            pageContext,
            isHtmlOnly,
            isClientRouting,
            pageFilesLoaded,
            pageFilesClientSide,
            pageFilesServerSide,
            clientEntries,
            clientDependencies
        });
    }
    return pageContextAddendum;
}
async function loadPageUserFiles(pageFilesAll, pageConfig, pageId, isDev) {
    const pageFilesServerSide = (0, getPageFiles_js_1.getPageFilesServerSide)(pageFilesAll, pageId);
    const pageConfigLoaded = !pageConfig ? null : await (0, loadConfigValues_js_1.loadConfigValues)(pageConfig, isDev);
    await Promise.all(pageFilesServerSide.map((p) => p.loadFile?.()));
    const pageContextExports = (0, getPageFiles_js_1.getPageContextExports)(pageFilesServerSide, pageConfigLoaded);
    return {
        pageContextExports,
        pageFilesLoaded: pageFilesServerSide
    };
}
