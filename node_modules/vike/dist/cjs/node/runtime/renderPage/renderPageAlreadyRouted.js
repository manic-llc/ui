"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPageAlreadyRouted = renderPageAlreadyRouted;
exports.prerenderPage = prerenderPage;
exports.prerender404Page = prerender404Page;
exports.getPageContextInitEnhanced = getPageContextInitEnhanced;
exports.getRenderContext = getRenderContext;
const error_page_js_1 = require("../../../shared/error-page.js");
const renderHtml_js_1 = require("../html/renderHtml.js");
const getPageFiles_js_1 = require("../../../shared/getPageFiles.js");
const utils_js_1 = require("../utils.js");
const serializePageContextClientSide_js_1 = require("../html/serializePageContextClientSide.js");
const getPageContextUrlComputed_js_1 = require("../../../shared/getPageContextUrlComputed.js");
const globalContext_js_1 = require("../globalContext.js");
const createHttpResponse_js_1 = require("./createHttpResponse.js");
const loadUserFilesServerSide_js_1 = require("./loadUserFilesServerSide.js");
const executeOnRenderHtmlHook_js_1 = require("./executeOnRenderHtmlHook.js");
const executeOnBeforeRenderAndDataHooks_js_1 = require("./executeOnBeforeRenderAndDataHooks.js");
const loggerRuntime_js_1 = require("./loggerRuntime.js");
const isNewError_js_1 = require("./isNewError.js");
const preparePageContextForUserConsumptionServerSide_js_1 = require("./preparePageContextForUserConsumptionServerSide.js");
const executeGuardHook_js_1 = require("../../../shared/route/executeGuardHook.js");
const loadPageRoutes_js_1 = require("../../../shared/route/loadPageRoutes.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const isServerSideError_js_1 = require("../../../shared/misc/isServerSideError.js");
const assertV1Design_js_1 = require("../../shared/assertV1Design.js");
async function renderPageAlreadyRouted(pageContext) {
    // pageContext.pageId can either be the:
    //  - ID of the page matching the routing, or the
    //  - ID of the error page `_error.page.js`.
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'pageId', 'string'));
    const isError = pageContext.is404 || !!pageContext.errorWhileRendering;
    (0, utils_js_1.assert)(isError === (pageContext.pageId === (0, error_page_js_1.getErrorPageId)(pageContext._pageFilesAll, pageContext._pageConfigs)));
    (0, utils_js_1.objectAssign)(pageContext, await (0, loadUserFilesServerSide_js_1.loadUserFilesServerSide)(pageContext));
    if (!isError) {
        await (0, executeGuardHook_js_1.executeGuardHook)(pageContext, (pageContext) => (0, preparePageContextForUserConsumptionServerSide_js_1.preparePageContextForUserConsumptionServerSide)(pageContext));
    }
    if (!isError) {
        await (0, executeOnBeforeRenderAndDataHooks_js_1.executeOnBeforeRenderAndDataHooks)(pageContext);
    }
    else {
        try {
            await (0, executeOnBeforeRenderAndDataHooks_js_1.executeOnBeforeRenderAndDataHooks)(pageContext);
        }
        catch (err) {
            if ((0, isNewError_js_1.isNewError)(err, pageContext.errorWhileRendering)) {
                (0, loggerRuntime_js_1.logRuntimeError)(err, pageContext._httpRequestId);
            }
        }
    }
    if (pageContext.isClientSideNavigation) {
        if (isError) {
            (0, utils_js_1.objectAssign)(pageContext, { [isServerSideError_js_1.isServerSideError]: true });
        }
        const pageContextSerialized = (0, serializePageContextClientSide_js_1.serializePageContextClientSide)(pageContext);
        const httpResponse = await (0, createHttpResponse_js_1.createHttpResponsePageContextJson)(pageContextSerialized);
        (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
    const renderHookResult = await (0, executeOnRenderHtmlHook_js_1.executeOnRenderHtmlHook)(pageContext);
    const { htmlRender, renderHook } = renderHookResult;
    const httpResponse = await (0, createHttpResponse_js_1.createHttpResponsePage)(htmlRender, renderHook, pageContext);
    (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
    return pageContext;
}
async function prerenderPage(pageContext) {
    (0, utils_js_1.objectAssign)(pageContext, {
        isClientSideNavigation: false,
        _urlHandler: null
    });
    /* Should we execute the guard() hook upon pre-rendering? Is there a use case for this?
     *  - It isn't trivial to implement, as it requires to duplicate / factor out the isAbortError() handling
    await executeGuardHook(pageContext, (pageContext) => preparePageContextForUserConsumptionServerSide(pageContext))
    */
    await (0, executeOnBeforeRenderAndDataHooks_js_1.executeOnBeforeRenderAndDataHooks)(pageContext);
    const { htmlRender, renderHook } = await (0, executeOnRenderHtmlHook_js_1.executeOnRenderHtmlHook)(pageContext);
    (0, utils_js_1.assertUsage)(htmlRender !== null, `Cannot pre-render ${picocolors_1.default.cyan(pageContext.urlOriginal)} because the ${renderHook.hookName}() hook defined by ${renderHook.hookFilePath} didn't return an HTML string.`);
    (0, utils_js_1.assert)(pageContext.isClientSideNavigation === false);
    const documentHtml = await (0, renderHtml_js_1.getHtmlString)(htmlRender);
    (0, utils_js_1.assert)(typeof documentHtml === 'string');
    if (!pageContext._usesClientRouter) {
        return { documentHtml, pageContextSerialized: null, pageContext };
    }
    else {
        const pageContextSerialized = (0, serializePageContextClientSide_js_1.serializePageContextClientSide)(pageContext);
        return { documentHtml, pageContextSerialized, pageContext };
    }
}
async function prerender404Page(renderContext, pageContextInit_) {
    const errorPageId = (0, error_page_js_1.getErrorPageId)(renderContext.pageFilesAll, renderContext.pageConfigs);
    if (!errorPageId) {
        return null;
    }
    const pageContext = {
        pageId: errorPageId,
        _httpRequestId: null,
        _urlRewrite: null,
        is404: true,
        routeParams: {},
        // `prerender404Page()` is about generating `dist/client/404.html` for static hosts; there is no Client Routing.
        _usesClientRouter: false,
        _debugRouteMatches: []
    };
    const pageContextInit = {
        urlOriginal: '/fake-404-url' // A URL is needed for `applyViteHtmlTransform`
    };
    (0, utils_js_1.objectAssign)(pageContextInit, pageContextInit_);
    {
        const pageContextInitEnhanced = getPageContextInitEnhanced(pageContextInit, renderContext);
        (0, utils_js_1.objectAssign)(pageContext, pageContextInitEnhanced);
    }
    (0, utils_js_1.objectAssign)(pageContext, await (0, loadUserFilesServerSide_js_1.loadUserFilesServerSide)(pageContext));
    return prerenderPage(pageContext);
}
function getPageContextInitEnhanced(pageContextInit, renderContext, { ssr: { urlRewrite, urlHandler, isClientSideNavigation } = {
    urlRewrite: null,
    urlHandler: null,
    isClientSideNavigation: false
} } = {}) {
    (0, utils_js_1.assert)(pageContextInit.urlOriginal);
    const globalContext = (0, globalContext_js_1.getGlobalContext)();
    const pageContextInitEnhanced = {};
    (0, utils_js_1.objectAssign)(pageContextInitEnhanced, pageContextInit);
    (0, utils_js_1.objectAssign)(pageContextInitEnhanced, {
        _objectCreatedByVike: true,
        // The following is defined on `pageContext` because we can eventually make these non-global (e.g. sot that two pages can have different includeAssetsImportedByServer settings)
        _baseServer: globalContext.baseServer,
        _baseAssets: globalContext.baseAssets,
        _includeAssetsImportedByServer: globalContext.includeAssetsImportedByServer,
        // TODO: use GloablContext instead
        _pageFilesAll: renderContext.pageFilesAll,
        _pageConfigs: renderContext.pageConfigs,
        _pageConfigGlobal: renderContext.pageConfigGlobal,
        _allPageIds: renderContext.allPageIds,
        _pageRoutes: renderContext.pageRoutes,
        _onBeforeRouteHook: renderContext.onBeforeRouteHook,
        _pageContextInit: pageContextInit,
        _urlRewrite: urlRewrite,
        _urlHandler: urlHandler,
        isClientSideNavigation
    });
    // pageContext.urlParsed
    const pageContextUrlComputed = (0, getPageContextUrlComputed_js_1.getPageContextUrlComputed)(pageContextInitEnhanced);
    (0, utils_js_1.objectAssign)(pageContextInitEnhanced, pageContextUrlComputed);
    // pageContext.headers
    {
        let headers;
        if (pageContextInit.headersOriginal) {
            headers = (0, utils_js_1.normalizeHeaders)(pageContextInit.headersOriginal);
            (0, utils_js_1.assertUsage)(!('headers' in pageContextInit), "You're defining pageContextInit.headersOriginal as well as pageContextInit.headers but you should only define pageContextInit.headersOriginal instead, see https://vike.dev/headers");
        }
        else if (pageContextInit.headers) {
            headers = pageContextInit.headers;
            // TODO/next-major-release: assertUsage() instead of assertWarning()
            (0, utils_js_1.assertWarning)(false, 'Setting pageContextInit.headers is deprecated: set pageContextInit.headersOriginal instead, see https://vike.dev/headers', { onlyOnce: true });
        }
        else {
            headers = null;
        }
        (0, utils_js_1.objectAssign)(pageContextInitEnhanced, { headers });
    }
    return pageContextInitEnhanced;
}
// TODO: remove getRenderContext() in favor of getGlobalObject() + reloadGlobalContext()
// TODO: impl GlobalNodeContext + GlobalClientContext + GloablContext, and use GlobalContext instead of RenderContext
async function getRenderContext() {
    const globalContext = (0, globalContext_js_1.getGlobalContext)();
    const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal } = await (0, getPageFiles_js_1.getPageFilesAll)(false, globalContext.isProduction);
    const { pageRoutes, onBeforeRouteHook } = await (0, loadPageRoutes_js_1.loadPageRoutes)(pageFilesAll, pageConfigs, pageConfigGlobal, allPageIds);
    (0, assertV1Design_js_1.assertV1Design)(
    // pageConfigs is PageConfigRuntime[] but assertV1Design() requires PageConfigBuildTime[]
    pageConfigs.length > 0, pageFilesAll);
    const renderContext = {
        pageFilesAll: pageFilesAll,
        pageConfigs,
        pageConfigGlobal,
        allPageIds: allPageIds,
        pageRoutes,
        onBeforeRouteHook
    };
    return renderContext;
}
