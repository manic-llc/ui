"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializePageContextClientSide = serializePageContextClientSide;
exports.serializePageContextAbort = serializePageContextAbort;
const stringify_1 = require("@brillout/json-serializer/stringify");
const utils_js_1 = require("../utils.js");
const error_page_js_1 = require("../../../shared/error-page.js");
const addIs404ToPageProps_js_1 = require("../../../shared/addIs404ToPageProps.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const notSerializable_js_1 = require("../../../shared/notSerializable.js");
const pageContextInitIsPassedToClient_js_1 = require("../../../shared/misc/pageContextInitIsPassedToClient.js");
const isServerSideError_js_1 = require("../../../shared/misc/isServerSideError.js");
const PASS_TO_CLIENT = [
    'abortReason',
    '_urlRewrite',
    '_urlRedirect',
    'abortStatusCode',
    '_abortCall',
    /* Not needed on the client-side
    '_abortCaller',
    */
    pageContextInitIsPassedToClient_js_1.pageContextInitIsPassedToClient,
    'pageId',
    'routeParams',
    'data' // for data() hook
];
const PASS_TO_CLIENT_ERROR_PAGE = ['pageProps', 'is404', isServerSideError_js_1.isServerSideError];
function serializePageContextClientSide(pageContext) {
    const passToClient = getPassToClient(pageContext);
    const pageContextClient = {};
    passToClient.forEach((prop) => {
        // We set non-existing props to `undefined`, in order to pass the list of passToClient values to the client-side
        pageContextClient[prop] = pageContext[prop];
    });
    if (Object.keys(pageContext._pageContextInit).some((p) => passToClient.includes(p))) {
        pageContextClient[pageContextInitIsPassedToClient_js_1.pageContextInitIsPassedToClient] = true;
    }
    let pageContextSerialized;
    try {
        pageContextSerialized = serialize(pageContextClient);
    }
    catch (err) {
        const h = (s) => picocolors_1.default.cyan(s);
        let hasWarned = false;
        const propsNonSerializable = [];
        passToClient.forEach((prop) => {
            const propName1 = (0, utils_js_1.getPropAccessNotation)(prop);
            const propName2 = JSON.stringify(prop);
            const varName = `pageContext${propName1}`;
            try {
                serialize(pageContext[prop], varName);
            }
            catch (err) {
                hasWarned = true;
                propsNonSerializable.push(prop);
                // useConfig() wrong usage
                if (prop === '_configFromHook') {
                    let pathString = '';
                    if ((0, stringify_1.isJsonSerializerError)(err)) {
                        pathString = err.pathString;
                    }
                    (0, utils_js_1.assertUsage)(false, `Cannot serialize config ${h(pathString)} set by useConfig(), see https://vike.dev/useConfig#serialization-error`);
                }
                // Non-serializable pageContext set by the user
                let msg = [
                    `${h(varName)} can't be serialized and, therefore, can't be passed to the client side.`,
                    `Make sure ${h(varName)} is serializable, or remove ${h(propName2)} from ${h('passToClient')}.`
                ].join(' ');
                if ((0, stringify_1.isJsonSerializerError)(err)) {
                    msg = `${msg} Serialization error: ${err.messageCore}.`;
                }
                else {
                    // When a property getter throws an error
                    console.warn('Serialization error:');
                    console.warn(err);
                    msg = `${msg} The serialization failed because of the error printed above.`;
                }
                // We warn (instead of throwing an error) since Vike's client runtime throws an error (with `assertUsage()`) if the user's client code tries to access the property that cannot be serialized
                (0, utils_js_1.assertWarning)(false, msg, { onlyOnce: false });
            }
        });
        (0, utils_js_1.assert)(hasWarned);
        propsNonSerializable.forEach((prop) => {
            pageContextClient[prop] = notSerializable_js_1.notSerializable;
        });
        try {
            pageContextSerialized = serialize(pageContextClient);
        }
        catch (err) {
            (0, utils_js_1.assert)(false);
        }
    }
    return pageContextSerialized;
}
function serialize(value, varName) {
    return (0, stringify_1.stringify)(value, { forbidReactElements: true, valueName: varName });
}
function getPassToClient(pageContext) {
    let passToClient = [...pageContext._passToClient, ...PASS_TO_CLIENT];
    if ((0, error_page_js_1.isErrorPage)(pageContext.pageId, pageContext._pageConfigs)) {
        (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'is404', 'boolean'));
        (0, addIs404ToPageProps_js_1.addIs404ToPageProps)(pageContext);
        passToClient.push(...PASS_TO_CLIENT_ERROR_PAGE);
    }
    passToClient = (0, utils_js_1.unique)(passToClient);
    return passToClient;
}
function serializePageContextAbort(pageContext) {
    (0, utils_js_1.assert)(pageContext._urlRedirect || pageContext._urlRewrite || pageContext.abortStatusCode);
    (0, utils_js_1.assert)(pageContext._abortCall);
    (0, utils_js_1.assert)(pageContext._abortCaller);
    // Not needed on the client-side
    delete pageContext._abortCaller;
    const unknownProps = Object.keys(pageContext).filter((prop) => ![
        // prettier-ignore
        // biome-ignore format:
        '_abortCall',
        /* Not needed on the client-side
        '_abortCaller',
        */
        '_urlRedirect',
        '_urlRewrite',
        'abortStatusCode',
        'abortReason',
        'is404',
        'pageProps'
    ].includes(prop));
    if (!pageContext._isLegacyRenderErrorPage) {
        (0, utils_js_1.assert)(unknownProps.length === 0);
    }
    else {
        // TODO/v1-release: remove
        (0, utils_js_1.assertWarning)(unknownProps.length === 0, [
            "The following pageContext values won't be available on the client-side:",
            unknownProps.map((p) => `  pageContext[${JSON.stringify(p)}]`),
            'Use `throw render()` instead of `throw RenderErrorPage()`'
        ].join('\n'), {
            onlyOnce: false
        });
    }
    return serialize(pageContext);
}
