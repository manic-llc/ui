"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPage_addWrapper = void 0;
exports.renderPage = renderPage;
const renderPageAlreadyRouted_js_1 = require("./renderPage/renderPageAlreadyRouted.js");
const index_js_1 = require("../../shared/route/index.js");
const utils_js_1 = require("./utils.js");
const abort_js_1 = require("../../shared/route/abort.js");
const globalContext_js_1 = require("./globalContext.js");
const handlePageContextRequestUrl_js_1 = require("./renderPage/handlePageContextRequestUrl.js");
const createHttpResponse_js_1 = require("./renderPage/createHttpResponse.js");
const loggerRuntime_js_1 = require("./renderPage/loggerRuntime.js");
const isNewError_js_1 = require("./renderPage/isNewError.js");
const assertArguments_js_1 = require("./renderPage/assertArguments.js");
const index_js_2 = require("./renderPage/log404/index.js");
const isConfigInvalid_js_1 = require("./renderPage/isConfigInvalid.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const serializePageContextClientSide_js_1 = require("./html/serializePageContextClientSide.js");
const error_page_js_1 = require("../../shared/error-page.js");
const handleErrorWithoutErrorPage_js_1 = require("./renderPage/handleErrorWithoutErrorPage.js");
const loadUserFilesServerSide_js_1 = require("./renderPage/loadUserFilesServerSide.js");
const resolveRedirects_js_1 = require("./renderPage/resolveRedirects.js");
const globalObject = (0, utils_js_1.getGlobalObject)('runtime/renderPage.ts', {
    httpRequestsCount: 0
});
let renderPage_wrapper = async (_httpRequestId, ret) => ({
    pageContextReturn: await ret()
});
const renderPage_addWrapper = (wrapper) => {
    renderPage_wrapper = wrapper;
};
exports.renderPage_addWrapper = renderPage_addWrapper;
// `renderPage()` calls `renderPageNominal()` while ensuring that errors are `console.error(err)` instead of `throw err`, so that Vike never triggers a server shut down. (Throwing an error in an Express.js middleware shuts down the whole Express.js server.)
async function renderPage(pageContextInit) {
    (0, assertArguments_js_1.assertArguments)(...arguments);
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContextInit, 'urlOriginal', 'string')); // assertUsage() already implemented at assertArguments()
    (0, utils_js_1.assertEnv)();
    assertIsUrl(pageContextInit.urlOriginal);
    const urlPathnameWithBase = (0, utils_js_1.parseUrl)(pageContextInit.urlOriginal, '/').pathname;
    assertIsNotViteRequest(urlPathnameWithBase, pageContextInit.urlOriginal);
    if (urlPathnameWithBase.endsWith('/favicon.ico'))
        return getPageContextHttpResponseFavicon404(pageContextInit);
    const httpRequestId = getRequestId();
    const urlOriginalPretty = (0, utils_js_1.getUrlPretty)(pageContextInit.urlOriginal);
    logHttpRequest(urlOriginalPretty, httpRequestId);
    const { pageContextReturn } = await renderPage_wrapper(httpRequestId, () => renderPageAndPrepare(pageContextInit, httpRequestId));
    logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn);
    (0, utils_js_1.checkType)(pageContextReturn);
    (0, utils_js_1.assert)(pageContextReturn.httpResponse);
    return pageContextReturn;
}
async function renderPageAndPrepare(pageContextInit, httpRequestId) {
    // Invalid config
    const handleInvalidConfig = (err) => {
        (0, loggerRuntime_js_1.logRuntimeInfo)?.(picocolors_1.default.bold(picocolors_1.default.red('Error while loading a Vike config file, see error above.')), httpRequestId, 'error');
        const pageContextWithError = getPageContextHttpResponseError(err, pageContextInit, null);
        return pageContextWithError;
    };
    if (isConfigInvalid_js_1.isConfigInvalid) {
        if (1 < 2 // Make TS happy
        ) {
            return handleInvalidConfig(isConfigInvalid_js_1.isConfigInvalid.err);
        }
    }
    // Prepare context
    let renderContext;
    try {
        await (0, globalContext_js_1.initGlobalContext_renderPage)();
        renderContext = await (0, renderPageAlreadyRouted_js_1.getRenderContext)();
    }
    catch (err) {
        // Errors are expected since assertUsage() is used in both initGlobalContext_renderPage() and getRenderContext().
        // initGlobalContext_renderPage() and getRenderContext() don't call any user hooks => err isn't thrown from user code.
        (0, utils_js_1.assert)(!(0, abort_js_1.isAbortError)(err));
        (0, loggerRuntime_js_1.logRuntimeError)(err, httpRequestId);
        const pageContextWithError = getPageContextHttpResponseError(err, pageContextInit, null);
        return pageContextWithError;
    }
    if (isConfigInvalid_js_1.isConfigInvalid) {
        return handleInvalidConfig(isConfigInvalid_js_1.isConfigInvalid.err);
    }
    else {
        // From now on, renderContext.pageConfigs contains all the configuration data; getVikeConfig() isn't called anymore for this request
    }
    // Check Base URL
    assertBaseUrl(pageContextInit);
    // Normalize URL
    {
        const pageContextHttpResponse = normalizeUrl(pageContextInit, httpRequestId);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    // Permanent redirects (HTTP status code `301`)
    {
        const pageContextHttpResponse = getPermanentRedirect(pageContextInit, httpRequestId);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    return await renderPageAlreadyPrepared(pageContextInit, httpRequestId, renderContext, []);
}
async function renderPageAlreadyPrepared(pageContextInit, httpRequestId, renderContext, pageContextsFromRewrite) {
    (0, abort_js_1.assertNoInfiniteAbortLoop)(pageContextsFromRewrite.length, 
    // There doesn't seem to be a way to count the number of HTTP redirects (vike don't have access to the HTTP request headers/cookies)
    // https://stackoverflow.com/questions/9683007/detect-infinite-http-redirect-loop-on-server-side
    0);
    let pageContextNominalPageSuccess;
    let pageContextNominalPageInit = {};
    {
        const pageContextFromAllRewrites = (0, abort_js_1.getPageContextFromAllRewrites)(pageContextsFromRewrite);
        (0, utils_js_1.objectAssign)(pageContextNominalPageInit, pageContextFromAllRewrites);
    }
    {
        const pageContextInitEnhanced = getPageContextInitEnhancedSSR(pageContextInit, renderContext, pageContextNominalPageInit._urlRewrite, httpRequestId);
        (0, utils_js_1.objectAssign)(pageContextNominalPageInit, pageContextInitEnhanced);
    }
    let errNominalPage;
    {
        try {
            pageContextNominalPageSuccess = await renderPageNominal(pageContextNominalPageInit);
        }
        catch (err) {
            errNominalPage = err;
            (0, utils_js_1.assert)(errNominalPage);
            (0, loggerRuntime_js_1.logRuntimeError)(errNominalPage, httpRequestId);
        }
        if (!errNominalPage) {
            (0, utils_js_1.assert)(pageContextNominalPageSuccess === pageContextNominalPageInit);
        }
    }
    // Log upon 404
    if (pageContextNominalPageSuccess &&
        'is404' in pageContextNominalPageSuccess &&
        pageContextNominalPageSuccess.is404 === true) {
        await (0, index_js_2.log404)(pageContextNominalPageSuccess);
    }
    if (errNominalPage === undefined) {
        (0, utils_js_1.assert)(pageContextNominalPageSuccess);
        return pageContextNominalPageSuccess;
    }
    else {
        (0, utils_js_1.assert)(errNominalPage);
        (0, utils_js_1.assert)(pageContextNominalPageSuccess === undefined);
        (0, utils_js_1.assert)(pageContextNominalPageInit);
        (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContextNominalPageInit, 'urlOriginal', 'string'));
        const pageContextErrorPageInit = await getPageContextErrorPageInit(pageContextInit, errNominalPage, pageContextNominalPageInit, renderContext, httpRequestId);
        // Handle `throw redirect()` and `throw render()` while rendering nominal page
        if ((0, abort_js_1.isAbortError)(errNominalPage)) {
            const handled = await handleAbortError(errNominalPage, pageContextsFromRewrite, pageContextInit, pageContextNominalPageInit, httpRequestId, renderContext, pageContextErrorPageInit);
            if (handled.pageContextReturn) {
                // - throw redirect()
                // - throw render(url)
                // - throw render(abortStatusCode) if .pageContext.json request
                return handled.pageContextReturn;
            }
            else {
                // - throw render(abortStatusCode) if not .pageContext.json request
            }
            Object.assign(pageContextErrorPageInit, handled.pageContextAbort);
        }
        {
            const errorPageId = (0, error_page_js_1.getErrorPageId)(renderContext.pageFilesAll, renderContext.pageConfigs);
            if (!errorPageId) {
                (0, utils_js_1.objectAssign)(pageContextErrorPageInit, { pageId: null });
                return (0, handleErrorWithoutErrorPage_js_1.handleErrorWithoutErrorPage)(pageContextErrorPageInit);
            }
            else {
                (0, utils_js_1.objectAssign)(pageContextErrorPageInit, { pageId: errorPageId });
            }
        }
        let pageContextErrorPage;
        try {
            pageContextErrorPage = await (0, renderPageAlreadyRouted_js_1.renderPageAlreadyRouted)(pageContextErrorPageInit);
        }
        catch (errErrorPage) {
            // Handle `throw redirect()` and `throw render()` while rendering error page
            if ((0, abort_js_1.isAbortError)(errErrorPage)) {
                const handled = await handleAbortError(errErrorPage, pageContextsFromRewrite, pageContextInit, pageContextNominalPageInit, httpRequestId, renderContext, pageContextErrorPageInit);
                // throw render(abortStatusCode)
                if (!handled.pageContextReturn) {
                    const pageContextAbort = errErrorPage._pageContextAbort;
                    (0, utils_js_1.assertWarning)(false, `Failed to render error page because ${picocolors_1.default.cyan(pageContextAbort._abortCall)} was called: make sure ${picocolors_1.default.cyan(pageContextAbort._abortCaller)} doesn't occur while the error page is being rendered.`, { onlyOnce: false });
                    const pageContextHttpWithError = getPageContextHttpResponseError(errNominalPage, pageContextInit, pageContextErrorPageInit);
                    return pageContextHttpWithError;
                }
                // `throw redirect()` / `throw render(url)`
                return handled.pageContextReturn;
            }
            if ((0, isNewError_js_1.isNewError)(errErrorPage, errNominalPage)) {
                (0, loggerRuntime_js_1.logRuntimeError)(errErrorPage, httpRequestId);
            }
            const pageContextWithError = getPageContextHttpResponseError(errNominalPage, pageContextInit, pageContextErrorPageInit);
            return pageContextWithError;
        }
        return pageContextErrorPage;
    }
}
function logHttpRequest(urlOriginal, httpRequestId) {
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(getRequestInfoMessage(urlOriginal), httpRequestId, 'info');
}
function getRequestInfoMessage(urlOriginal) {
    return `HTTP request: ${prettyUrl(urlOriginal)}`;
}
function logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn) {
    const statusCode = pageContextReturn.httpResponse?.statusCode ?? null;
    let msg;
    let isNominal;
    {
        const { errorWhileRendering } = pageContextReturn;
        const isSkipped = statusCode === null && !errorWhileRendering;
        if (isSkipped) {
            // - URL doesn't include Base URL
            //   - Can we abort earlier so that `logHttpResponse()` and `logHttpRequest()` aren't even called?
            // - Error loading a Vike config file
            //   - We should show `HTTP response ${urlOriginalPretty} ERR` instead.
            //   - Maybe we can/should make the error available at pageContext.errorWhileRendering
            (0, utils_js_1.assert)(errorWhileRendering === null || errorWhileRendering === undefined);
            msg = `HTTP response ${prettyUrl(urlOriginalPretty)} ${picocolors_1.default.dim('null')}`;
            // Erroneous value (it shoud sometimes be `false`) but it's fine as it doesn't seem to have much of an impact.
            isNominal = true;
        }
        else {
            const isSuccess = statusCode !== null && statusCode >= 200 && statusCode <= 399;
            isNominal = isSuccess || statusCode === 404;
            const color = (s) => picocolors_1.default.bold(isSuccess ? picocolors_1.default.green(String(s)) : picocolors_1.default.red(String(s)));
            const isRedirect = statusCode && 300 <= statusCode && statusCode <= 399;
            const type = isRedirect ? 'redirect' : 'response';
            if (isRedirect) {
                (0, utils_js_1.assert)(pageContextReturn.httpResponse);
                const headerRedirect = pageContextReturn.httpResponse.headers
                    .slice()
                    .reverse()
                    .find((header) => header[0] === 'Location');
                (0, utils_js_1.assert)(headerRedirect);
                const urlRedirect = headerRedirect[1];
                urlOriginalPretty = urlRedirect;
            }
            msg = `HTTP ${type} ${prettyUrl(urlOriginalPretty)} ${color(statusCode ?? 'ERR')}`;
        }
    }
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(msg, httpRequestId, isNominal ? 'info' : 'error');
}
function prettyUrl(url) {
    return picocolors_1.default.bold(decodeURI(url));
}
function getPageContextHttpResponseError(err, pageContextInit, pageContext) {
    const pageContextWithError = createPageContext(pageContextInit);
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseError)(pageContext);
    (0, utils_js_1.objectAssign)(pageContextWithError, {
        httpResponse,
        errorWhileRendering: err
    });
    return pageContextWithError;
}
function getPageContextHttpResponseFavicon404(pageContextInit) {
    const pageContext = createPageContext(pageContextInit);
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseFavicon404)();
    (0, utils_js_1.objectAssign)(pageContext, {
        httpResponse
    });
    (0, utils_js_1.checkType)(pageContext);
    return pageContext;
}
function createPageContext(pageContextInit) {
    const pageContext = {
        _isPageContextObject: true
    };
    Object.assign(pageContext, pageContextInit);
    return pageContext;
}
async function renderPageNominal(pageContext) {
    (0, utils_js_1.objectAssign)(pageContext, { errorWhileRendering: null });
    // Route
    {
        const pageContextFromRoute = await (0, index_js_1.route)(pageContext);
        (0, utils_js_1.objectAssign)(pageContext, pageContextFromRoute);
        (0, utils_js_1.objectAssign)(pageContext, { is404: pageContext.pageId ? null : true });
        if (pageContext.pageId === null) {
            const errorPageId = (0, error_page_js_1.getErrorPageId)(pageContext._pageFilesAll, pageContext._pageConfigs);
            if (!errorPageId) {
                (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'pageId', 'null'));
                return (0, handleErrorWithoutErrorPage_js_1.handleErrorWithoutErrorPage)(pageContext);
            }
            (0, utils_js_1.objectAssign)(pageContext, { pageId: errorPageId });
        }
    }
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'pageId', 'string'));
    (0, utils_js_1.assert)(pageContext.errorWhileRendering === null);
    // Render
    const pageContextAfterRender = await (0, renderPageAlreadyRouted_js_1.renderPageAlreadyRouted)(pageContext);
    (0, utils_js_1.assert)(pageContext === pageContextAfterRender);
    return pageContextAfterRender;
}
async function getPageContextErrorPageInit(pageContextInit, errNominalPage, pageContextNominalPagePartial, renderContext, httpRequestId) {
    const pageContextInitEnhanced = getPageContextInitEnhancedSSR(pageContextInit, renderContext, null, httpRequestId);
    (0, utils_js_1.assert)(errNominalPage);
    const pageContext = {};
    (0, utils_js_1.objectAssign)(pageContext, pageContextInitEnhanced);
    (0, utils_js_1.objectAssign)(pageContext, {
        is404: false,
        errorWhileRendering: errNominalPage,
        routeParams: {}
    });
    (0, utils_js_1.objectAssign)(pageContext, {
        _debugRouteMatches: pageContextNominalPagePartial._debugRouteMatches || 'ROUTING_ERROR'
    });
    (0, utils_js_1.assert)(pageContext.errorWhileRendering);
    return pageContext;
}
function getPageContextInitEnhancedSSR(pageContextInit, renderContext, urlRewrite, httpRequestId) {
    const { isClientSideNavigation, _urlHandler } = handlePageContextUrl(pageContextInit.urlOriginal);
    const pageContextInitEnhanced = (0, renderPageAlreadyRouted_js_1.getPageContextInitEnhanced)(pageContextInit, renderContext, {
        ssr: {
            urlRewrite,
            urlHandler: _urlHandler,
            isClientSideNavigation
        }
    });
    (0, utils_js_1.objectAssign)(pageContextInitEnhanced, { _httpRequestId: httpRequestId });
    return pageContextInitEnhanced;
}
function handlePageContextUrl(urlOriginal) {
    const { isPageContextRequest } = (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(urlOriginal);
    return {
        isClientSideNavigation: isPageContextRequest,
        _urlHandler: (url) => (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(url).urlWithoutPageContextRequestSuffix
    };
}
function getRequestId() {
    const httpRequestId = ++globalObject.httpRequestsCount;
    (0, utils_js_1.assert)(httpRequestId >= 1);
    return httpRequestId;
}
function assertIsUrl(urlOriginal) {
    (0, utils_js_1.assertUsage)((0, utils_js_1.isUrl)(urlOriginal), `${picocolors_1.default.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${picocolors_1.default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which isn't a valid URL.`);
}
function assertIsNotViteRequest(urlPathname, urlOriginal) {
    const isViteRequest = urlPathname.startsWith('/@vite/client') || urlPathname.startsWith('/@fs/') || urlPathname.startsWith('/__vite_ping');
    (0, utils_js_1.assertUsage)(!isViteRequest, `${picocolors_1.default.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${picocolors_1.default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which is unexpected because this URL should have already been handled by Vite's development middleware. Make sure to 1. install Vite's development middleware and 2. add Vite's middleware *before* Vike's middleware, see https://vike.dev/renderPage`);
}
function normalizeUrl(pageContextInit, httpRequestId) {
    const { trailingSlash, disableUrlNormalization, baseServer } = (0, globalContext_js_1.getGlobalContext)();
    if (disableUrlNormalization)
        return null;
    const { urlOriginal } = pageContextInit;
    const { isPageContextRequest } = (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(urlOriginal);
    if (isPageContextRequest)
        return null;
    const urlNormalized = (0, utils_js_1.normalizeUrlPathname)(urlOriginal, trailingSlash, baseServer);
    if (!urlNormalized)
        return null;
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(`URL normalized from ${picocolors_1.default.cyan(urlOriginal)} to ${picocolors_1.default.cyan(urlNormalized)} (https://vike.dev/url-normalization)`, httpRequestId, 'info');
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseRedirect)({ url: urlNormalized, statusCode: 301 }, pageContextInit.urlOriginal);
    const pageContextHttpResponse = createPageContext(pageContextInit);
    (0, utils_js_1.objectAssign)(pageContextHttpResponse, { httpResponse });
    return pageContextHttpResponse;
}
function getPermanentRedirect(pageContextInit, httpRequestId) {
    const { redirects, baseServer } = (0, globalContext_js_1.getGlobalContext)();
    const urlWithoutBase = (0, utils_js_1.removeBaseServer)(pageContextInit.urlOriginal, baseServer);
    let origin = null;
    let urlTargetExternal = null;
    let urlTarget = (0, utils_js_1.modifyUrlPathname)(urlWithoutBase, (urlPathname) => {
        const urlTarget = (0, resolveRedirects_js_1.resolveRedirects)(redirects, urlPathname);
        if (urlTarget === null)
            return null;
        if (!(0, utils_js_1.isUrl)(urlTarget)) {
            // E.g. `urlTarget === 'mailto:some@example.com'`
            (0, utils_js_1.assert)((0, utils_js_1.isUri)(urlTarget));
            urlTargetExternal = urlTarget;
            return null;
        }
        const { urlModified, origin: origin_ } = (0, utils_js_1.removeUrlOrigin)(urlTarget);
        origin = origin_;
        return urlModified;
    });
    if (urlTargetExternal) {
        urlTarget = urlTargetExternal;
    }
    else {
        let originChanged = false;
        if (origin) {
            const urlModified = (0, utils_js_1.setUrlOrigin)(urlTarget, origin);
            if (urlModified !== false) {
                originChanged = true;
                urlTarget = urlModified;
            }
        }
        if (normalize(urlTarget) === normalize(urlWithoutBase))
            return null;
        if (!originChanged)
            urlTarget = (0, utils_js_1.prependBase)(urlTarget, baseServer);
        (0, utils_js_1.assert)(urlTarget !== pageContextInit.urlOriginal);
    }
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(`Permanent redirection defined by config.redirects (https://vike.dev/redirects)`, httpRequestId, 'info');
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseRedirect)({ url: urlTarget, statusCode: 301 }, urlWithoutBase);
    const pageContextHttpResponse = createPageContext(pageContextInit);
    (0, utils_js_1.objectAssign)(pageContextHttpResponse, { httpResponse });
    return pageContextHttpResponse;
}
function normalize(url) {
    return url || '/';
}
async function handleAbortError(errAbort, pageContextsFromRewrite, pageContextInit, 
// handleAbortError() creates a new pageContext object and we don't merge pageContextNominalPageInit to it: we only use some pageContextNominalPageInit information.
pageContextNominalPageInit, httpRequestId, renderContext, pageContextErrorPageInit) {
    (0, abort_js_1.logAbortErrorHandled)(errAbort, (0, globalContext_js_1.getGlobalContext)().isProduction, pageContextNominalPageInit);
    const pageContextAbort = errAbort._pageContextAbort;
    let pageContextSerialized;
    if (pageContextNominalPageInit.isClientSideNavigation) {
        if (pageContextAbort.abortStatusCode) {
            const errorPageId = (0, error_page_js_1.getErrorPageId)(renderContext.pageFilesAll, renderContext.pageConfigs);
            const abortCall = pageContextAbort._abortCall;
            (0, utils_js_1.assert)(abortCall);
            (0, utils_js_1.assertUsage)(errorPageId, `You called ${picocolors_1.default.cyan(abortCall)} but you didn't define an error page, make sure to define one https://vike.dev/error-page`);
            const pageContext = createPageContext({});
            (0, utils_js_1.objectAssign)(pageContext, { pageId: errorPageId });
            (0, utils_js_1.objectAssign)(pageContext, pageContextAbort);
            (0, utils_js_1.objectAssign)(pageContext, pageContextErrorPageInit);
            (0, utils_js_1.objectAssign)(pageContext, renderContext);
            (0, utils_js_1.objectAssign)(pageContext, await (0, loadUserFilesServerSide_js_1.loadUserFilesServerSide)(pageContext));
            // We include pageContextInit: we don't only serialize pageContextAbort because the error page may need to access pageContextInit
            pageContextSerialized = (0, serializePageContextClientSide_js_1.serializePageContextClientSide)(pageContext);
        }
        else {
            pageContextSerialized = (0, serializePageContextClientSide_js_1.serializePageContextAbort)(pageContextAbort);
        }
        const httpResponse = await (0, createHttpResponse_js_1.createHttpResponsePageContextJson)(pageContextSerialized);
        const pageContextReturn = { httpResponse };
        return { pageContextReturn };
    }
    if (pageContextAbort._urlRewrite) {
        const pageContextReturn = await renderPageAlreadyPrepared(pageContextInit, httpRequestId, renderContext, [
            ...pageContextsFromRewrite,
            pageContextAbort
        ]);
        Object.assign(pageContextReturn, pageContextAbort);
        return { pageContextReturn };
    }
    if (pageContextAbort._urlRedirect) {
        const pageContextReturn = createPageContext(pageContextInit);
        (0, utils_js_1.objectAssign)(pageContextReturn, pageContextAbort);
        const httpResponse = (0, createHttpResponse_js_1.createHttpResponseRedirect)(pageContextAbort._urlRedirect, (() => {
            const { pathname, searchOriginal } = pageContextNominalPageInit.urlParsed;
            const urlLogical = (0, utils_js_1.createUrlFromComponents)(null, pathname, searchOriginal, 
            // The server-side doesn't have access to the hash
            null);
            return urlLogical;
        })());
        (0, utils_js_1.objectAssign)(pageContextReturn, { httpResponse });
        return { pageContextReturn };
    }
    (0, utils_js_1.assert)(pageContextAbort.abortStatusCode);
    return { pageContextAbort };
}
function assertBaseUrl(pageContextInit) {
    const { baseServer } = (0, globalContext_js_1.getGlobalContext)();
    const { urlOriginal } = pageContextInit;
    const { urlWithoutPageContextRequestSuffix } = (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(urlOriginal);
    const { hasBaseServer } = (0, utils_js_1.parseUrl)(urlWithoutPageContextRequestSuffix, baseServer);
    (0, utils_js_1.assertUsage)(hasBaseServer, `${picocolors_1.default.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${picocolors_1.default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which doesn't start with Base URL ${picocolors_1.default.code(baseServer)} (https://vike.dev/base-url)`);
}
