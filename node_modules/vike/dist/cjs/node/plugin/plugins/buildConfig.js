"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.manifestTempFile = void 0;
exports.buildConfig = buildConfig;
exports.assertRollupInput = assertRollupInput;
exports.analyzeClientEntries = analyzeClientEntries;
const utils_js_1 = require("../utils.js");
const getVikeConfig_js_1 = require("./importUserCode/v1-design/getVikeConfig.js");
const findPageFiles_js_1 = require("../shared/findPageFiles.js");
const getConfigVike_js_1 = require("../../shared/getConfigVike.js");
const virtualFilePageConfigValuesAll_js_1 = require("../../shared/virtual-files/virtualFilePageConfigValuesAll.js");
const extractAssetsQuery_js_1 = require("../../shared/extractAssetsQuery.js");
const module_1 = require("module");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const fixServerAssets_js_1 = require("./buildConfig/fixServerAssets.js");
const index_js_1 = require("./importBuild/index.js");
const prependEntriesDir_js_1 = require("../../shared/prependEntriesDir.js");
const getFilePath_js_1 = require("../shared/getFilePath.js");
const getConfigValueBuildTime_js_1 = require("../../../shared/page-configs/getConfigValueBuildTime.js");
// @ts-ignore Shimmed by dist-cjs-fixup.js for CJS build.
const importMetaUrl = `file://${__filename}`;
const require_ = (0, module_1.createRequire)(importMetaUrl);
const manifestTempFile = '_temp_manifest.json';
exports.manifestTempFile = manifestTempFile;
function buildConfig() {
    let isServerAssetsFixEnabled;
    let isSsrBuild;
    let outDirs;
    let config;
    return [
        {
            name: 'vike:buildConfig:configResolved',
            apply: 'build',
            enforce: 'post',
            configResolved: {
                order: 'post',
                async handler(config_) {
                    config = config_;
                    (0, utils_js_1.assertNodeEnv_build)();
                    assertRollupInput(config);
                    const entries = await getEntries(config);
                    (0, utils_js_1.assert)(Object.keys(entries).length > 0);
                    config.build.rollupOptions.input = (0, utils_js_1.injectRollupInputs)(entries, config);
                    addLogHook();
                    outDirs = (0, utils_js_1.getOutDirs)(config);
                    {
                        isServerAssetsFixEnabled = (0, fixServerAssets_js_1.fixServerAssets_isEnabled)() && (await (0, getVikeConfig_js_1.isV1Design)(config, false));
                        if (isServerAssetsFixEnabled) {
                            // https://github.com/vikejs/vike/issues/1339
                            config.build.ssrEmitAssets = true;
                            // Required if `ssrEmitAssets: true`, see https://github.com/vitejs/vite/pull/11430#issuecomment-1454800934
                            config.build.cssMinify = 'esbuild';
                        }
                    }
                }
            },
            config(config) {
                (0, utils_js_1.assertNodeEnv_build)();
                isSsrBuild = (0, utils_js_1.viteIsSSR)(config);
                return {
                    build: {
                        outDir: (0, utils_js_1.resolveOutDir)(config),
                        manifest: manifestTempFile,
                        copyPublicDir: !isSsrBuild
                    }
                };
            },
            buildStart() {
                (0, utils_js_1.assertNodeEnv_build)();
            }
        },
        {
            name: 'vike:buildConfig:writeBundle',
            apply: 'build',
            // Make sure other writeBundle() hooks are called after this writeBundle() hook.
            //  - set_ASSETS_MAP() needs to be called before dist/server/ code is executed.
            //    - For example, the writeBundle() hook of vite-plugin-vercel needs to be called after this writeBundle() hook, otherwise: https://github.com/vikejs/vike/issues/1527
            enforce: 'pre',
            writeBundle: {
                order: 'pre',
                sequential: true,
                async handler(options, bundle) {
                    if (isSsrBuild) {
                        // Ideally we'd move dist/_temp_manifest.json to dist/server/client-assets.json instead of dist/assets.json
                        //  - But we can't because there is no guarentee whether dist/server/ is generated before or after dist/client/ (generating dist/server/ after dist/client/ erases dist/server/client-assets.json)
                        //  - We'll able to do so once we replace `$ vite build` with `$ vike build`
                        const assetsJsonFilePath = path_1.default.posix.join(outDirs.outDirRoot, 'assets.json');
                        const clientManifestFilePath = path_1.default.posix.join(outDirs.outDirClient, manifestTempFile);
                        const serverManifestFilePath = path_1.default.posix.join(outDirs.outDirServer, manifestTempFile);
                        if (!isServerAssetsFixEnabled) {
                            await promises_1.default.copyFile(clientManifestFilePath, assetsJsonFilePath);
                        }
                        else {
                            const clientManifestMod = await (0, fixServerAssets_js_1.fixServerAssets)(config);
                            await promises_1.default.writeFile(assetsJsonFilePath, JSON.stringify(clientManifestMod, null, 2), 'utf-8');
                        }
                        await promises_1.default.rm(clientManifestFilePath);
                        await promises_1.default.rm(serverManifestFilePath);
                        await (0, index_js_1.set_ASSETS_MAP)(options, bundle);
                    }
                }
            }
        }
    ];
}
async function getEntries(config) {
    const configVike = await (0, getConfigVike_js_1.getConfigVike)(config);
    const pageFileEntries = await getPageFileEntries(config, configVike.includeAssetsImportedByServer); // TODO/v1-release: remove
    const { pageConfigs } = await (0, getVikeConfig_js_1.getVikeConfig)(config, false);
    (0, utils_js_1.assertUsage)(Object.keys(pageFileEntries).length !== 0 || pageConfigs.length !== 0, 'At least one page should be defined, see https://vike.dev/add');
    if ((0, utils_js_1.viteIsSSR)(config)) {
        const pageEntries = getPageEntries(pageConfigs);
        const entries = {
            // importBuild: resolve('dist/esm/node/importBuild.js'), // TODO/next-major-release: remove
            ...pageFileEntries,
            // Ensure Rollup generates a bundle per page: https://github.com/vikejs/vike/issues/349#issuecomment-1166247275
            ...pageEntries
        };
        return entries;
    }
    else {
        let { hasClientRouting, hasServerRouting, clientEntries } = analyzeClientEntries(pageConfigs, config);
        if (Object.entries(pageFileEntries).length > 0) {
            hasClientRouting = true;
            hasServerRouting = true;
        }
        const entries = {
            ...clientEntries,
            ...pageFileEntries
        };
        const clientRoutingEntry = resolve(`dist/esm/client/client-routing-runtime/entry.js`);
        const serverRoutingEntry = resolve(`dist/esm/client/server-routing-runtime/entry.js`);
        if (hasClientRouting) {
            entries['entries/entry-client-routing'] = clientRoutingEntry;
        }
        if (hasServerRouting) {
            entries['entries/entry-server-routing'] = serverRoutingEntry;
        }
        return entries;
    }
}
function getPageEntries(pageConfigs) {
    const pageEntries = {};
    pageConfigs.forEach((pageConfig) => {
        const { entryName, entryTarget } = getEntryFromPageConfig(pageConfig, false);
        pageEntries[entryName] = entryTarget;
    });
    return pageEntries;
}
function analyzeClientEntries(pageConfigs, config) {
    let hasClientRouting = false;
    let hasServerRouting = false;
    let clientEntries = {};
    let clientEntryList = [];
    pageConfigs.forEach((pageConfig) => {
        const configValue = (0, getConfigValueBuildTime_js_1.getConfigValueBuildTime)(pageConfig, 'clientRouting', 'boolean');
        if (configValue?.value) {
            hasClientRouting = true;
        }
        else {
            hasServerRouting = true;
        }
        {
            // Ensure Rollup generates a bundle per page: https://github.com/vikejs/vike/issues/349#issuecomment-1166247275
            const { entryName, entryTarget } = getEntryFromPageConfig(pageConfig, true);
            clientEntries[entryName] = entryTarget;
        }
        {
            const clientEntry = (0, getConfigValueBuildTime_js_1.getConfigValueBuildTime)(pageConfig, 'client', 'string')?.value ?? null;
            if (clientEntry) {
                clientEntryList.push(clientEntry);
            }
        }
    });
    clientEntryList = (0, utils_js_1.unique)(clientEntryList);
    clientEntryList.forEach((clientEntry) => {
        const { entryName, entryTarget } = getEntryFromClientEntry(clientEntry, config);
        clientEntries[entryName] = entryTarget;
    });
    return { hasClientRouting, hasServerRouting, clientEntries };
}
// Ensure Rollup creates entries for each page file, see https://github.com/vikejs/vike/issues/350
// (Otherwise the page files may be missing in the client manifest.json)
async function getPageFileEntries(config, includeAssetsImportedByServer) {
    const isForClientSide = !(0, utils_js_1.viteIsSSR)(config);
    const fileTypes = isForClientSide ? ['.page', '.page.client'] : ['.page', '.page.server'];
    if (isForClientSide && includeAssetsImportedByServer) {
        fileTypes.push('.page.server');
    }
    let pageFiles = await (0, findPageFiles_js_1.findPageFiles)(config, fileTypes, false);
    const pageFileEntries = {};
    pageFiles = (0, utils_js_1.unique)(pageFiles);
    pageFiles.forEach((pageFile) => {
        let addExtractAssetsQuery = false;
        if (isForClientSide && pageFile.includes('.page.server.')) {
            (0, utils_js_1.assert)(includeAssetsImportedByServer);
            addExtractAssetsQuery = true;
        }
        const { entryName, entryTarget } = getEntryFromClientEntry(pageFile, config, addExtractAssetsQuery);
        pageFileEntries[entryName] = entryTarget;
    });
    return pageFileEntries;
}
function getEntryFromClientEntry(clientEntry, config, addExtractAssetsQuery) {
    if (!clientEntry.startsWith('/')) {
        (0, utils_js_1.assertIsNpmPackageImport)(clientEntry);
        const entryTarget = clientEntry;
        const entryName = (0, prependEntriesDir_js_1.prependEntriesDir)(clientEntry);
        return { entryName, entryTarget };
    }
    const filePathAbsoluteUserRootDir = clientEntry;
    (0, utils_js_1.assert)(filePathAbsoluteUserRootDir.startsWith('/'));
    const filePath = (0, getFilePath_js_1.getFilePathResolved)({
        filePathAbsoluteUserRootDir,
        userRootDir: config.root
    });
    let entryTarget = filePath.filePathAbsoluteFilesystem;
    if (addExtractAssetsQuery)
        entryTarget = (0, extractAssetsQuery_js_1.extractAssetsAddQuery)(entryTarget);
    let entryName = filePathAbsoluteUserRootDir;
    if (addExtractAssetsQuery)
        entryName = (0, extractAssetsQuery_js_1.extractAssetsAddQuery)(entryName);
    entryName = (0, utils_js_1.removeFileExtention)(entryName);
    entryName = (0, prependEntriesDir_js_1.prependEntriesDir)(entryName);
    return { entryName, entryTarget };
}
function getEntryFromPageConfig(pageConfig, isForClientSide) {
    let { pageId } = pageConfig;
    const entryTarget = (0, virtualFilePageConfigValuesAll_js_1.getVirtualFileIdPageConfigValuesAll)(pageId, isForClientSide);
    let entryName = pageId;
    // Avoid:
    // ```
    // dist/client/assets/entries/.Dp9wM6PK.js
    // dist/server/entries/.mjs
    // ```
    if (entryName === '/')
        entryName = 'root';
    entryName = (0, prependEntriesDir_js_1.prependEntriesDir)(entryName);
    (0, utils_js_1.assert)(!entryName.endsWith('/'));
    return { entryName, entryTarget };
}
function resolve(filePath) {
    (0, utils_js_1.assert)(filePath.startsWith('dist/'));
    // [RELATIVE_PATH_FROM_DIST] Current directory: node_modules/vike/dist/esm/node/plugin/plugins/
    return require_.resolve(`../../../../../${filePath}`);
}
function addLogHook() {
    const tty = process.stdout.isTTY && !process.env.CI; // Equals https://github.com/vitejs/vite/blob/193d55c7b9cbfec5b79ebfca276d4a721e7de14d/packages/vite/src/node/plugins/reporter.ts#L27
    if (!tty)
        return;
    let lastLog = null;
    ['stdout', 'stderr'].forEach((stdName) => {
        var methodOriginal = process[stdName].write;
        process[stdName].write = function (...args) {
            lastLog = String(args[0]);
            return methodOriginal.apply(process[stdName], args);
        };
    });
    // Exhaustive list extracted from writeLine() calls at https://github.com/vitejs/vite/blob/193d55c7b9cbfec5b79ebfca276d4a721e7de14d/packages/vite/src/node/plugins/reporter.ts
    // prettier-ignore
    // biome-ignore format:
    const viteTransientLogs = [
        'transforming (',
        'rendering chunks (',
        'computing gzip size ('
    ];
    (0, utils_js_1.addOnBeforeLogHook)(() => {
        // Using viteTransientLogs is very conservative as clearing the current line is low risk. (We can assume that important messages, such as errors, include a trailing new line. Usually, only transient messages have no trailing new lines.)
        if (viteTransientLogs.some((s) => lastLog?.startsWith(s))) {
            process.stdout.clearLine(0);
            process.stdout.cursorTo(0);
        }
    });
}
function assertRollupInput(config) {
    const userInputs = (0, utils_js_1.normalizeRollupInput)(config.build.rollupOptions.input);
    const htmlInputs = Object.values(userInputs).filter((entry) => entry.endsWith('.html') || entry.endsWith('.htm'));
    const htmlInput = htmlInputs[0];
    (0, utils_js_1.assertUsage)(htmlInput === undefined, `The entry ${htmlInput} of config build.rollupOptions.input is an HTML entry which is forbidden when using Vike, instead follow https://vike.dev/add`);
}
