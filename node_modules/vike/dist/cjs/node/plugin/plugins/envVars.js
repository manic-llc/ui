"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.envVarsPlugin = envVarsPlugin;
const vite_1 = require("vite");
const utils_js_1 = require("../utils.js");
const rollupSourceMap_js_1 = require("../shared/rollupSourceMap.js");
const getFilePath_js_1 = require("../shared/getFilePath.js");
const normalizeId_js_1 = require("../shared/normalizeId.js");
// TODO/enventually: (after we implemented vike.config.js)
// - Make import.meta.env work inside +config.js
//   - For it to work, we'll probably need the user to define the settings (e.g. `envDir`) for loadEnv() inside vike.config.js instead of vite.config.js
//   - Or stop using Vite's `mode` implemention and have Vike implement its own `mode` feature? (So that the only dependencies are `$ vike build --mode staging` and `$ MODE=staging vike build`.)
const PUBLIC_ENV_PREFIX = 'PUBLIC_ENV__';
const PUBLIC_ENV_WHITELIST = [
    // https://github.com/vikejs/vike/issues/1724
    'STORYBOOK'
];
function envVarsPlugin() {
    let envsAll;
    let config;
    return {
        name: 'vike:envVars',
        enforce: 'post',
        configResolved(config_) {
            config = config_;
            config.command;
            envsAll = (0, vite_1.loadEnv)(config.mode, config.envDir || config.root, '');
            config.plugins.sort((0, utils_js_1.lowerFirst)((plugin) => (plugin.name === 'vite:define' ? 1 : 0)));
        },
        transform(code, id, options) {
            id = (0, normalizeId_js_1.normalizeId)(id);
            (0, utils_js_1.assertPosixPath)(id);
            if (id.includes('/node_modules/'))
                return;
            (0, utils_js_1.assertPosixPath)(config.root);
            if (!id.startsWith(config.root))
                return;
            if (!code.includes('import.meta.env.'))
                return;
            const isBuild = config.command === 'build';
            const isClientSide = getIsClientSide(config, options);
            Object.entries(envsAll)
                .filter(([key]) => {
                // Already handled by Vite
                const envPrefix = !config.envPrefix ? [] : (0, utils_js_1.isArray)(config.envPrefix) ? config.envPrefix : [config.envPrefix];
                return !envPrefix.some((prefix) => key.startsWith(prefix));
            })
                .forEach(([envName, envVal]) => {
                const envStatement = `import.meta.env.${envName}`;
                const envStatementRegEx = new RegExp((0, utils_js_1.escapeRegex)(envStatement) + '\\b', 'g');
                // Security check
                {
                    const isPrivate = !envName.startsWith(PUBLIC_ENV_PREFIX) && !PUBLIC_ENV_WHITELIST.includes(envName);
                    if (isPrivate && isClientSide) {
                        if (!envStatementRegEx.test(code))
                            return;
                        const modulePath = (0, getFilePath_js_1.getModuleFilePathAbsolute)(id, config);
                        const errMsgAddendum = isBuild ? '' : ' (Vike will prevent your app from building for production)';
                        const keyPublic = `${PUBLIC_ENV_PREFIX}${envName}`;
                        const errMsg = `${envStatement} is used in client-side file ${modulePath} which means that the environment variable ${envName} will be included in client-side bundles and, therefore, ${envName} will be publicly exposed which can be a security leak${errMsgAddendum}. Use ${envStatement} only in server-side files, or rename ${envName} to ${keyPublic}, see https://vike.dev/env`;
                        if (isBuild) {
                            (0, utils_js_1.assertUsage)(false, errMsg);
                        }
                        else {
                            // - Only a warning for faster development DX (e.g. when user toggles `ssr: boolean` or `onBeforeRenderIsomorph: boolean`).
                            // - But only showing a warning can be confusing: https://github.com/vikejs/vike/issues/1641
                            (0, utils_js_1.assertWarning)(false, errMsg, { onlyOnce: true });
                        }
                    }
                    // Double check
                    (0, utils_js_1.assert)(!(isPrivate && isClientSide) || !isBuild);
                }
                // Apply
                code = applyEnvVar(envStatementRegEx, envVal, code);
            });
            // Line numbers didn't change.
            //  - We only break the column number of a couple of lines, wich is acceptable.
            //  - Anyways, I'm not even sure Vite supports high-resolution column number source mapping.
            const ret = (0, rollupSourceMap_js_1.sourceMapPassthrough)(code);
            return ret;
        }
    };
}
function applyEnvVar(envStatementRegEx, envVal, code) {
    return code.replace(envStatementRegEx, JSON.stringify(envVal));
}
function getIsClientSide(config, options) {
    const isBuild = config.command === 'build';
    if (isBuild) {
        (0, utils_js_1.assert)(typeof config.build.ssr === 'boolean');
        const isServerSide = config.build.ssr;
        if (options !== undefined) {
            (0, utils_js_1.assert)(options.ssr === isServerSide);
        }
        return !isServerSide;
    }
    else {
        (0, utils_js_1.assert)(config.build.ssr === false);
        (0, utils_js_1.assert)(typeof options?.ssr === 'boolean');
        const isServerSide = options.ssr;
        return !isServerSide;
    }
}
