"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixServerAssets = fixServerAssets;
exports.fixServerAssets_isEnabled = fixServerAssets_isEnabled;
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const utils_js_1 = require("../../utils.js");
const virtualFilePageConfigValuesAll_js_1 = require("../../../shared/virtual-files/virtualFilePageConfigValuesAll.js");
const buildConfig_js_1 = require("../buildConfig.js");
const getAssetsDir_js_1 = require("../../shared/getAssetsDir.js");
/**
 * true  => use workaround config.build.ssrEmitAssets
 * false => use workaround extractAssets plugin
 *
 * Only used by V1 design.
 */
function fixServerAssets_isEnabled() {
    // We currently apply the workaround iff V1 design.
    // Shall we allow the user to toggle between the two workarounds? E.g. based on https://vike.dev/includeAssetsImportedByServer.
    return true;
}
/** https://github.com/vikejs/vike/issues/1339 */
async function fixServerAssets(config) {
    const outDirs = (0, utils_js_1.getOutDirs)(config);
    const clientManifest = await loadManifest(outDirs.outDirClient);
    const serverManifest = await loadManifest(outDirs.outDirServer);
    const { clientManifestMod, filesToCopy } = addServerAssets(clientManifest, serverManifest);
    await copyAssets(filesToCopy, config);
    return clientManifestMod;
}
async function loadManifest(outDir) {
    const manifestFilePath = path_1.default.posix.join(outDir, buildConfig_js_1.manifestTempFile);
    const manifestFileContent = await promises_1.default.readFile(manifestFilePath, 'utf-8');
    (0, utils_js_1.assert)(manifestFileContent);
    const manifest = JSON.parse(manifestFileContent);
    (0, utils_js_1.assert)(manifest);
    return manifest;
}
async function copyAssets(filesToCopy, config) {
    const { outDirClient, outDirServer } = (0, utils_js_1.getOutDirs)(config);
    const assetsDir = (0, getAssetsDir_js_1.getAssetsDir)(config);
    const assetsDirServer = path_1.default.posix.join(outDirServer, assetsDir);
    if (!filesToCopy.length)
        return;
    (0, utils_js_1.assert)((0, fs_1.existsSync)(assetsDirServer));
    const concurrencyLimit = (0, utils_js_1.pLimit)(10);
    await Promise.all(filesToCopy.map((file) => concurrencyLimit(() => 
    // TODO: move instead of copying
    promises_1.default.cp(path_1.default.posix.join(outDirServer, file), path_1.default.posix.join(outDirClient, file), {
        recursive: true
    }))));
    /* We cannot do that because, with some edge case Rollup settings (outputing JavaScript chunks and static assets to the same directoy), this removes JavaScript chunks, see https://github.com/vikejs/vike/issues/1154#issuecomment-1975762404
    await fs.rm(assetsDirServer, { recursive: true })
    */
}
// Add serverManifest resources to clientManifest
function addServerAssets(clientManifest, serverManifest) {
    var _a, _b;
    const entriesClient = new Map();
    const entriesServer = new Map();
    for (const [key, entry] of Object.entries(clientManifest)) {
        const pageId = getPageId(key);
        if (!pageId)
            continue;
        const resources = collectResources(entry, clientManifest);
        (0, utils_js_1.assert)(!entriesClient.has(pageId));
        entriesClient.set(pageId, { key, ...resources });
    }
    for (const [key, entry] of Object.entries(serverManifest)) {
        const pageId = getPageId(key);
        if (!pageId)
            continue;
        const resources = collectResources(entry, serverManifest);
        (0, utils_js_1.assert)(!entriesServer.has(pageId));
        entriesServer.set(pageId, resources);
    }
    let filesToCopy = [];
    for (const [pageId, entryClient] of entriesClient.entries()) {
        const cssToAdd = [];
        const assetsToAdd = [];
        const entryServer = entriesServer.get(pageId);
        if (entryServer) {
            cssToAdd.push(...entryServer.css
                .filter((cssServer) => !entryClient.css.some((cssClient) => cssServer.hash === cssClient.hash))
                .map((css) => css.src));
            assetsToAdd.push(...entryServer.assets
                .filter((assertServer) => !entryClient.assets.some((assetClient) => assertServer.hash === assetClient.hash))
                .map((asset) => asset.src));
        }
        const { key } = entryClient;
        if (cssToAdd.length) {
            filesToCopy.push(...cssToAdd);
            (_a = clientManifest[key]).css ?? (_a.css = []);
            clientManifest[key].css?.push(...cssToAdd);
        }
        if (assetsToAdd.length) {
            filesToCopy.push(...assetsToAdd);
            (_b = clientManifest[key]).assets ?? (_b.assets = []);
            clientManifest[key].assets?.push(...assetsToAdd);
        }
    }
    const clientManifestMod = clientManifest;
    filesToCopy = (0, utils_js_1.unique)(filesToCopy);
    return { clientManifestMod, filesToCopy };
}
function getPageId(key) {
    // Normalize from:
    //   ../../virtual:vike:pageConfigValuesAll:client:/pages/index
    // to:
    //   virtual:vike:pageConfigValuesAll:client:/pages/index
    // (This seems to be needed only for vitest tests that use Vite's build() API with an inline config.)
    key = key.substring(key.indexOf('virtual:vike'));
    const result = (0, virtualFilePageConfigValuesAll_js_1.isVirtualFileIdPageConfigValuesAll)(key);
    return result && result.pageId;
}
function collectResources(entryRoot, manifest) {
    const css = [];
    const assets = [];
    const entries = new Set([entryRoot]);
    for (const entry of entries) {
        for (const entryImport of entry.imports ?? []) {
            entries.add(manifest[entryImport]);
        }
        const entryCss = entry.css ?? [];
        if (entry.file.endsWith('.css'))
            entryCss.push(entry.file);
        for (const src of entryCss) {
            const hash = getHash(src);
            css.push({ src, hash });
        }
        const entryAssets = entry.assets ?? [];
        for (const src of entryAssets) {
            const hash = getHash(src);
            assets.push({ src, hash });
        }
    }
    return { css, assets };
}
// Use the hash of resources to determine whether they are equal. We need this, otherwise we get:
// ```html
// <head>
//   <link rel="stylesheet" type="text/css" href="/assets/static/onRenderClient.2j6TxKIB.css">
//   <link rel="stylesheet" type="text/css" href="/assets/static/onRenderHtml.2j6TxKIB.css">
// </head>
// ```
function getHash(src) {
    // src is guarenteed to end with `.[hash][extname]`, see distFileNames.ts
    const hash = src.split('.').at(-2);
    (0, utils_js_1.assert)(hash);
    return hash;
}
