"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vikeConfigDependencies = void 0;
exports.getVikeConfig = getVikeConfig;
exports.reloadVikeConfig = reloadVikeConfig;
exports.isVikeConfigFile = isVikeConfigFile;
exports.isV1Design = isV1Design;
exports.getConfigValueInterfaceFile = getConfigValueInterfaceFile;
const utils_js_1 = require("../../../utils.js");
const path_1 = __importDefault(require("path"));
const configDefinitionsBuiltIn_js_1 = require("./getVikeConfig/configDefinitionsBuiltIn.js");
const filesystemRouting_js_1 = require("./getVikeConfig/filesystemRouting.js");
const transpileAndExecuteFile_js_1 = require("./getVikeConfig/transpileAndExecuteFile.js");
const isConfigInvalid_js_1 = require("../../../../runtime/renderPage/isConfigInvalid.js");
const globalContext_js_1 = require("../../../../runtime/globalContext.js");
const loggerNotProd_js_1 = require("../../../shared/loggerNotProd.js");
const removeSuperfluousViteLog_js_1 = require("../../../shared/loggerVite/removeSuperfluousViteLog.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const getConfigDefinedAt_js_1 = require("../../../../../shared/page-configs/getConfigDefinedAt.js");
const crawlPlusFiles_js_1 = require("./getVikeConfig/crawlPlusFiles.js");
const getConfigFileExport_js_1 = require("./getConfigFileExport.js");
const loadFileAtConfigTime_js_1 = require("./getVikeConfig/loadFileAtConfigTime.js");
const resolvePointerImport_js_1 = require("./getVikeConfig/resolvePointerImport.js");
const getFilePath_js_1 = require("../../../shared/getFilePath.js");
const getConfigValueBuildTime_js_1 = require("../../../../../shared/page-configs/getConfigValueBuildTime.js");
const getConfigVike_js_1 = require("../../../../shared/getConfigVike.js");
const assertExtensions_js_1 = require("./assertExtensions.js");
(0, utils_js_1.assertIsNotProductionRuntime)();
let devServerIsCorrupt = false;
let wasConfigInvalid = null;
let vikeConfigPromise = null;
const vikeConfigDependencies = new Set();
exports.vikeConfigDependencies = vikeConfigDependencies;
function reloadVikeConfig(userRootDir, outDirRoot) {
    vikeConfigDependencies.clear();
    (0, resolvePointerImport_js_1.clearFilesEnvMap)();
    vikeConfigPromise = loadVikeConfig_withErrorHandling(userRootDir, outDirRoot, true, true);
    handleReloadSideEffects();
}
async function handleReloadSideEffects() {
    wasConfigInvalid = !!isConfigInvalid_js_1.isConfigInvalid;
    const vikeConfigPromisePrevious = vikeConfigPromise;
    try {
        await vikeConfigPromise;
    }
    catch (err) {
        // handleReloadSideEffects() is only called in dev.
        // In dev, if loadVikeConfig_withErrorHandling() throws an error, then it's a vike bug.
        console.error(err);
        (0, utils_js_1.assert)(false);
    }
    if (vikeConfigPromise !== vikeConfigPromisePrevious) {
        // Let the next handleReloadSideEffects() call handle side effects
        return;
    }
    if (!isConfigInvalid_js_1.isConfigInvalid) {
        if (wasConfigInvalid) {
            wasConfigInvalid = false;
            (0, loggerNotProd_js_1.logConfigErrorRecover)();
        }
        if (devServerIsCorrupt) {
            devServerIsCorrupt = false;
            const viteDevServer = (0, globalContext_js_1.getViteDevServer)();
            (0, utils_js_1.assert)(viteDevServer);
            (0, removeSuperfluousViteLog_js_1.removeSuperfluousViteLog_enable)();
            await viteDevServer.restart(true);
            (0, removeSuperfluousViteLog_js_1.removeSuperfluousViteLog_disable)();
        }
    }
}
async function getVikeConfig(config, isDev, { crawlWithGit, tolerateInvalidConfig } = {}) {
    const { outDirRoot } = (0, utils_js_1.getOutDirs)(config);
    const userRootDir = config.root;
    if (!vikeConfigPromise) {
        const crawlWithGit_ = crawlWithGit !== undefined ? crawlWithGit : (await (0, getConfigVike_js_1.getConfigVike)(config)).crawl.git;
        vikeConfigPromise = loadVikeConfig_withErrorHandling(userRootDir, outDirRoot, isDev, crawlWithGit_, tolerateInvalidConfig);
    }
    return await vikeConfigPromise;
}
async function isV1Design(config, isDev) {
    const vikeConfig = await getVikeConfig(config, isDev);
    const { pageConfigs } = vikeConfig;
    const isV1Design = pageConfigs.length > 0;
    return isV1Design;
}
async function loadInterfaceFiles(userRootDir, outDirRoot, isDev, crawlWithGit) {
    const plusFiles = await findPlusFiles(userRootDir, outDirRoot, isDev, crawlWithGit);
    const configFiles = [];
    const valueFiles = [];
    plusFiles.forEach((f) => {
        if (getConfigName(f.filePathAbsoluteFilesystem) === 'config') {
            configFiles.push(f);
        }
        else {
            valueFiles.push(f);
        }
    });
    let interfaceFilesByLocationId = {};
    await Promise.all([
        // Config files
        ...configFiles.map(async (filePath) => {
            const { filePathAbsoluteUserRootDir } = filePath;
            (0, utils_js_1.assert)(filePathAbsoluteUserRootDir);
            const { configFile, extendsConfigs } = await (0, loadFileAtConfigTime_js_1.loadConfigFile)(filePath, userRootDir, [], false);
            (0, utils_js_1.assert)(filePath.filePathAbsoluteUserRootDir);
            const locationId = (0, filesystemRouting_js_1.getLocationId)(filePathAbsoluteUserRootDir);
            const interfaceFile = getInterfaceFileFromConfigFile(configFile, false, locationId);
            interfaceFilesByLocationId[locationId] = interfaceFilesByLocationId[locationId] ?? [];
            interfaceFilesByLocationId[locationId].push(interfaceFile);
            extendsConfigs.forEach((extendsConfig) => {
                /* We purposely use the same locationId because the Vike extension's config should only apply to where it's being extended from, for example:
                ```js
                // /pages/admin/+config.js
        
                import vikeVue from 'vike-vue/config'
                // Should only apply to /pages/admin/**
                export default { extends: [vikeVue] }
                ```
                ```js
                // /pages/marketing/+config.js
        
                import vikeReact from 'vike-react/config'
                // Should only apply to /pages/marketing/**
                export default { extends: [vikeReact] }
                ```
                */
                const interfaceFile = getInterfaceFileFromConfigFile(extendsConfig, true, locationId);
                (0, assertExtensions_js_1.assertExtensionsConventions)(interfaceFile);
                interfaceFilesByLocationId[locationId].push(interfaceFile);
            });
        }),
        // Value files
        ...valueFiles.map(async (filePath) => {
            const { filePathAbsoluteUserRootDir } = filePath;
            (0, utils_js_1.assert)(filePathAbsoluteUserRootDir);
            const configName = getConfigName(filePathAbsoluteUserRootDir);
            (0, utils_js_1.assert)(configName);
            const locationId = (0, filesystemRouting_js_1.getLocationId)(filePathAbsoluteUserRootDir);
            const interfaceFile = {
                locationId,
                filePath,
                fileExportsByConfigName: {
                    [configName]: {}
                },
                isConfigFile: false,
                isValueFile: true,
                configName
            };
            {
                // We don't have access to the custom config definitions defined by the user yet.
                //  - If `configDef` is `undefined` => we load the file +{configName}.js later.
                //  - We already need to load +meta.js here (to get the custom config definitions defined by the user)
                const configDef = getConfigDefinitionOptional(configDefinitionsBuiltIn_js_1.configDefinitionsBuiltIn, configName);
                if (configDef && isLoadableAtBuildTime(configDef)) {
                    await (0, loadFileAtConfigTime_js_1.loadValueFile)(interfaceFile, configName, userRootDir);
                }
            }
            {
                interfaceFilesByLocationId[locationId] = interfaceFilesByLocationId[locationId] ?? [];
                interfaceFilesByLocationId[locationId].push(interfaceFile);
            }
        })
    ]);
    assertAllConfigsAreKnown(interfaceFilesByLocationId);
    return interfaceFilesByLocationId;
}
function getInterfaceFileFromConfigFile(configFile, isConfigExtend, locationId) {
    const { fileExports, filePath, extendsFilePaths } = configFile;
    const interfaceFile = {
        locationId,
        filePath,
        fileExportsByConfigName: {},
        isConfigFile: true,
        isValueFile: false,
        isConfigExtend,
        extendsFilePaths
    };
    const fileExport = (0, getConfigFileExport_js_1.getConfigFileExport)(fileExports, filePath.filePathToShowToUser);
    Object.entries(fileExport).forEach(([configName, configValue]) => {
        interfaceFile.fileExportsByConfigName[configName] = { configValue };
    });
    return interfaceFile;
}
/** Show error message upon unknown config */
function assertAllConfigsAreKnown(interfaceFilesByLocationId) {
    (0, utils_js_1.objectEntries)(interfaceFilesByLocationId).forEach(([locationId, interfaceFiles]) => {
        const interfaceFilesRelevant = getInterfaceFilesRelevant(interfaceFilesByLocationId, locationId);
        const configDefinitions = getConfigDefinitions(interfaceFilesRelevant);
        interfaceFiles.forEach((interfaceFile) => {
            Object.keys(interfaceFile.fileExportsByConfigName).forEach((configName) => {
                assertConfigExists(configName, Object.keys(configDefinitions), interfaceFile.filePath.filePathToShowToUser);
            });
        });
    });
}
async function loadVikeConfig_withErrorHandling(userRootDir, outDirRoot, isDev, crawlWithGit, tolerateInvalidConfig) {
    let hasError = false;
    let ret;
    let err;
    try {
        ret = await loadVikeConfig(userRootDir, outDirRoot, isDev, crawlWithGit);
    }
    catch (err_) {
        hasError = true;
        err = err_;
    }
    if (!hasError) {
        (0, utils_js_1.assert)(ret);
        (0, utils_js_1.assert)(err === undefined);
        (0, isConfigInvalid_js_1.isConfigInvalid_set)(false);
        return ret;
    }
    else {
        (0, utils_js_1.assert)(ret === undefined);
        (0, utils_js_1.assert)(err);
        (0, isConfigInvalid_js_1.isConfigInvalid_set)({ err });
        if (!isDev) {
            (0, utils_js_1.assert)((0, globalContext_js_1.getViteDevServer)() === null);
            throw err;
        }
        else {
            (0, loggerNotProd_js_1.logConfigError)(err);
            if (!tolerateInvalidConfig) {
                devServerIsCorrupt = true;
            }
            const dummyData = {
                pageConfigs: [],
                pageConfigGlobal: {
                    configDefinitions: {},
                    configValueSources: {}
                },
                globalVikeConfig: {}
            };
            return dummyData;
        }
    }
}
async function loadVikeConfig(userRootDir, outDirRoot, isDev, crawlWithGit) {
    const interfaceFilesByLocationId = await loadInterfaceFiles(userRootDir, outDirRoot, isDev, crawlWithGit);
    const importedFilesLoaded = {};
    const { globalVikeConfig, pageConfigGlobal } = await getGlobalConfigs(interfaceFilesByLocationId, userRootDir, importedFilesLoaded);
    const pageConfigs = await Promise.all((0, utils_js_1.objectEntries)(interfaceFilesByLocationId)
        .filter(([pageId, interfaceFiles]) => isDefiningPage(interfaceFiles))
        .map(async ([locationId]) => {
        const interfaceFilesRelevant = getInterfaceFilesRelevant(interfaceFilesByLocationId, locationId);
        const interfaceFilesRelevantList = Object.values(interfaceFilesRelevant).flat(1);
        (0, assertExtensions_js_1.assertExtensionsPeerDependencies)(interfaceFilesRelevantList);
        const configDefinitions = getConfigDefinitions(interfaceFilesRelevant);
        // Load value files of custom config-only configs
        await Promise.all(interfaceFilesRelevantList.map(async (interfaceFile) => {
            if (!interfaceFile.isValueFile)
                return;
            const { configName } = interfaceFile;
            if (isGlobalConfig(configName))
                return;
            const configDef = getConfigDefinition(configDefinitions, configName, interfaceFile.filePath.filePathToShowToUser);
            if (!isLoadableAtBuildTime(configDef))
                return;
            const isAlreadyLoaded = interfacefileIsAlreaydLoaded(interfaceFile);
            if (isAlreadyLoaded)
                return;
            // Value files of built-in configs should have already been loaded at loadInterfaceFiles()
            (0, utils_js_1.assert)(!(configName in configDefinitionsBuiltIn_js_1.configDefinitionsBuiltIn));
            await (0, loadFileAtConfigTime_js_1.loadValueFile)(interfaceFile, configName, userRootDir);
        }));
        let configValueSources = {};
        await Promise.all((0, utils_js_1.objectEntries)(configDefinitions)
            .filter(([configName]) => !isGlobalConfig(configName))
            .map(async ([configName, configDef]) => {
            const sources = await resolveConfigValueSources(configName, configDef, interfaceFilesRelevant, userRootDir, importedFilesLoaded);
            if (sources.length === 0)
                return;
            configValueSources[configName] = sources;
        }));
        configValueSources = sortConfigValueSources(configValueSources, locationId);
        const { routeFilesystem, isErrorPage } = determineRouteFilesystem(locationId, configValueSources);
        applyEffectsAll(configValueSources, configDefinitions);
        const configValuesComputed = getComputed(configValueSources, configDefinitions);
        assertUsageGlobalConfigs(interfaceFilesRelevantList, configDefinitions, interfaceFilesByLocationId);
        const pageConfig = {
            pageId: locationId,
            isErrorPage,
            routeFilesystem,
            configDefinitions,
            configValueSources,
            configValuesComputed
        };
        return pageConfig;
    }));
    assertPageConfigs(pageConfigs);
    return { pageConfigs, pageConfigGlobal, globalVikeConfig };
}
// TODO/soon: refactor
//  - Dedupe: most of the assertUsageGlobalConfigs() code below is a copy-paste of the assertUsage() logic inside getGlobalConfigs()
//    - This assertUsage() message is slightly better: use this one for getGlobalConfigs()
// Global configs should be defined at global locations
function assertUsageGlobalConfigs(interfaceFilesRelevantList, configDefinitions, interfaceFilesByLocationId) {
    interfaceFilesRelevantList.forEach((interfaceFile) => {
        const configNames = [];
        if (interfaceFile.isValueFile) {
            configNames.push(interfaceFile.configName);
        }
        else {
            configNames.push(...Object.keys(interfaceFile.fileExportsByConfigName));
        }
        configNames.forEach((configName) => {
            if (isGlobalConfig(configName))
                return;
            const configDef = getConfigDefinition(configDefinitions, configName, interfaceFile.filePath.filePathToShowToUser);
            if (configDef.global) {
                const locationIds = (0, utils_js_1.objectKeys)(interfaceFilesByLocationId);
                if (!(0, filesystemRouting_js_1.isGlobalLocation)(interfaceFile.locationId, locationIds)) {
                    const interfaceFilesGlobal = (0, utils_js_1.objectFromEntries)((0, utils_js_1.objectEntries)(interfaceFilesByLocationId).filter(([locationId]) => {
                        return (0, filesystemRouting_js_1.isGlobalLocation)(locationId, locationIds);
                    }));
                    const configFilesGlobal = [];
                    (0, utils_js_1.objectEntries)(interfaceFilesGlobal).forEach(([locationId, interfaceFiles]) => {
                        (0, utils_js_1.assert)((0, filesystemRouting_js_1.isGlobalLocation)(locationId, locationIds));
                        interfaceFiles.forEach((interfaceFile) => {
                            if (!interfaceFile.isConfigFile)
                                return;
                            const { filePath: { filePathAbsoluteUserRootDir } } = interfaceFile;
                            if (filePathAbsoluteUserRootDir) {
                                configFilesGlobal.push(filePathAbsoluteUserRootDir);
                            }
                        });
                    });
                    (0, utils_js_1.assertUsage)(false, [
                        `${interfaceFile.filePath.filePathToShowToUser} sets the config ${picocolors_1.default.cyan(configName)} but it's a global config:`,
                        configFilesGlobal.length > 0
                            ? `define ${picocolors_1.default.cyan(configName)} at ${(0, utils_js_1.joinEnglish)(configFilesGlobal, 'or')} instead.`
                            : `create a global config (e.g. /pages/+config.js) and define ${picocolors_1.default.cyan(configName)} there instead.`
                    ].join(' '));
                }
            }
        });
    });
}
function deriveConfigEnvFromFileName(env, fileName) {
    env = { ...env };
    if (fileName.includes('.server.')) {
        env.server = true;
        env.client = false;
    }
    else if (fileName.includes('.client.')) {
        env.client = true;
        env.server = false;
    }
    else if (fileName.includes('.shared.')) {
        env.server = true;
        env.client = true;
    }
    return env;
}
function assertPageConfigs(pageConfigs) {
    pageConfigs.forEach((pageConfig) => {
        assertOnBeforeRenderEnv(pageConfig);
    });
}
function assertOnBeforeRenderEnv(pageConfig) {
    const onBeforeRenderConfig = pageConfig.configValueSources.onBeforeRender?.[0];
    if (!onBeforeRenderConfig)
        return;
    const onBeforeRenderEnv = onBeforeRenderConfig.configEnv;
    const isClientRouting = (0, getConfigValueBuildTime_js_1.getConfigValueBuildTime)(pageConfig, 'clientRouting', 'boolean');
    // When using Server Routing, loading a onBeforeRender() hook on the client-side hasn't any effect (the Server Routing's client runtime never calls it); it unnecessarily bloats client bundle sizes
    (0, utils_js_1.assertUsage)(!(onBeforeRenderEnv.client && !isClientRouting), `Page ${pageConfig.pageId} has an onBeforeRender() hook with env ${picocolors_1.default.cyan(JSON.stringify(onBeforeRenderEnv))} which doesn't make sense because the page is using Server Routing: onBeforeRender() can be run in the client only when using Client Routing.`);
}
function interfacefileIsAlreaydLoaded(interfaceFile) {
    const configMapValues = Object.values(interfaceFile.fileExportsByConfigName);
    const isAlreadyLoaded = configMapValues.some((conf) => 'configValue' in conf);
    if (isAlreadyLoaded) {
        (0, utils_js_1.assert)(configMapValues.every((conf) => 'configValue' in conf));
    }
    return isAlreadyLoaded;
}
function getInterfaceFilesRelevant(interfaceFilesByLocationId, locationIdPage) {
    const interfaceFilesRelevant = Object.fromEntries((0, utils_js_1.objectEntries)(interfaceFilesByLocationId)
        .filter(([locationId]) => {
        return (0, filesystemRouting_js_1.isInherited)(locationId, locationIdPage);
    })
        .sort(([locationId1], [locationId2]) => (0, filesystemRouting_js_1.sortAfterInheritanceOrder)(locationId1, locationId2, locationIdPage)));
    return interfaceFilesRelevant;
}
async function getGlobalConfigs(interfaceFilesByLocationId, userRootDir, importedFilesLoaded) {
    const locationIds = (0, utils_js_1.objectKeys)(interfaceFilesByLocationId);
    const interfaceFilesGlobal = (0, utils_js_1.objectFromEntries)((0, utils_js_1.objectEntries)(interfaceFilesByLocationId).filter(([locationId]) => {
        return (0, filesystemRouting_js_1.isGlobalLocation)(locationId, locationIds);
    }));
    // Validate that global configs live in global interface files
    {
        const interfaceFilesGlobalPaths = [];
        (0, utils_js_1.objectEntries)(interfaceFilesGlobal).forEach(([locationId, interfaceFiles]) => {
            (0, utils_js_1.assert)((0, filesystemRouting_js_1.isGlobalLocation)(locationId, locationIds));
            interfaceFiles.forEach(({ filePath: { filePathAbsoluteUserRootDir } }) => {
                if (filePathAbsoluteUserRootDir) {
                    interfaceFilesGlobalPaths.push(filePathAbsoluteUserRootDir);
                }
            });
        });
        const globalPaths = Array.from(new Set(interfaceFilesGlobalPaths.map((p) => path_1.default.posix.dirname(p))));
        (0, utils_js_1.objectEntries)(interfaceFilesByLocationId).forEach(([locationId, interfaceFiles]) => {
            interfaceFiles.forEach((interfaceFile) => {
                Object.keys(interfaceFile.fileExportsByConfigName).forEach((configName) => {
                    if (!(0, filesystemRouting_js_1.isGlobalLocation)(locationId, locationIds) && isGlobalConfig(configName)) {
                        (0, utils_js_1.assertUsage)(false, [
                            `${interfaceFile.filePath.filePathToShowToUser} defines the config ${picocolors_1.default.cyan(configName)} which is global:`,
                            globalPaths.length
                                ? `define ${picocolors_1.default.cyan(configName)} in ${(0, utils_js_1.joinEnglish)(globalPaths, 'or')} instead`
                                : `create a global config (e.g. /pages/+config.js) and define ${picocolors_1.default.cyan(configName)} there instead`
                        ].join(' '));
                    }
                });
            });
        });
    }
    const globalVikeConfig = {};
    const pageConfigGlobal = {
        configDefinitions: configDefinitionsBuiltIn_js_1.configDefinitionsBuiltInGlobal,
        configValueSources: {}
    };
    await Promise.all((0, utils_js_1.objectEntries)(configDefinitionsBuiltIn_js_1.configDefinitionsBuiltInGlobal).map(async ([configName, configDef]) => {
        const sources = await resolveConfigValueSources(configName, configDef, interfaceFilesGlobal, userRootDir, importedFilesLoaded);
        const configValueSource = sources[0];
        if (!configValueSource)
            return;
        if (configName === 'onBeforeRoute' || configName === 'onPrerenderStart') {
            (0, utils_js_1.assert)(!('value' in configValueSource));
            pageConfigGlobal.configValueSources[configName] = [configValueSource];
        }
        else {
            (0, utils_js_1.assert)('value' in configValueSource);
            if (configName === 'prerender' && typeof configValueSource.value === 'boolean')
                return;
            const { filePathToShowToUser } = configValueSource.definedAtFilePath;
            (0, utils_js_1.assertWarning)(false, `Being able to define config ${picocolors_1.default.cyan(configName)} in ${filePathToShowToUser} is experimental and will likely be removed. Define the config ${picocolors_1.default.cyan(configName)} in Vike's Vite plugin options instead.`, { onlyOnce: true });
            globalVikeConfig[configName] = configValueSource.value;
        }
    }));
    return { pageConfigGlobal, globalVikeConfig };
}
async function resolveConfigValueSources(configName, configDef, interfaceFilesRelevant, userRootDir, importedFilesLoaded) {
    const sourcesInfo = [];
    // interfaceFilesRelevant is sorted by sortAfterInheritanceOrder()
    for (const interfaceFiles of Object.values(interfaceFilesRelevant)) {
        const interfaceFilesDefiningConfig = interfaceFiles.filter((interfaceFile) => interfaceFile.fileExportsByConfigName[configName]);
        if (interfaceFilesDefiningConfig.length === 0)
            continue;
        const visited = new WeakSet();
        const add = (interfaceFile) => {
            (0, utils_js_1.assert)(!visited.has(interfaceFile));
            visited.add(interfaceFile);
            const isHighestInheritancePrecedence = sourcesInfo.length === 0;
            sourcesInfo.push([
                configName,
                interfaceFile,
                configDef,
                userRootDir,
                importedFilesLoaded,
                isHighestInheritancePrecedence
            ]);
        };
        // Main resolution logic
        {
            const interfaceValueFiles = interfaceFilesDefiningConfig
                .filter((interfaceFile) => interfaceFile.isValueFile &&
                // We consider side-effect configs (e.g. `export { frontmatter }` of .mdx files) later (i.e. with less priority)
                interfaceFile.configName === configName)
                .sort(makeOrderDeterministic);
            const interfaceConfigFiles = interfaceFilesDefiningConfig
                .filter((interfaceFile) => interfaceFile.isConfigFile &&
                // We consider value from extended configs (e.g. vike-react) later (i.e. with less priority)
                !interfaceFile.isConfigExtend)
                .sort(makeOrderDeterministic);
            const interfaceValueFile = interfaceValueFiles[0];
            const interfaceConfigFile = interfaceConfigFiles[0];
            // Make this value:
            //   /pages/some-page/+{configName}.js > `export default`
            // override that value:
            //   /pages/some-page/+config.js > `export default { someConfig }`
            const interfaceFileWinner = interfaceValueFile ?? interfaceConfigFile;
            if (interfaceFileWinner) {
                const interfaceFilesOverriden = [...interfaceValueFiles, ...interfaceConfigFiles].filter((f) => f !== interfaceFileWinner);
                // A user-land conflict of interfaceFiles with the same locationId means that the user has superfluously defined the config twice; the user should remove such redundancy making things unnecessarily ambiguous
                warnOverridenConfigValues(interfaceFileWinner, interfaceFilesOverriden, configName);
                [interfaceFileWinner, ...interfaceFilesOverriden].forEach((interfaceFile) => {
                    add(interfaceFile);
                });
            }
        }
        // Side-effect configs such as `export { frontmatter }` in .mdx files
        interfaceFilesDefiningConfig
            .filter((interfaceFile) => interfaceFile.isValueFile &&
            // Is side-effect config
            interfaceFile.configName !== configName)
            .forEach((interfaceValueFileSideEffect) => {
            add(interfaceValueFileSideEffect);
        });
        // extends
        interfaceFilesDefiningConfig
            .filter((interfaceFile) => interfaceFile.isConfigFile && interfaceFile.isConfigExtend)
            // extended config files are already sorted by inheritance order
            .forEach((interfaceFile) => {
            add(interfaceFile);
        });
        interfaceFilesDefiningConfig.forEach((interfaceFile) => {
            (0, utils_js_1.assert)(visited.has(interfaceFile));
        });
    }
    const sources = await Promise.all(sourcesInfo.map(async (args) => await getConfigValueSource(...args)));
    return sources;
}
function makeOrderDeterministic(interfaceFile1, interfaceFile2) {
    return (0, utils_js_1.lowerFirst)((interfaceFile) => {
        const { filePathAbsoluteUserRootDir } = interfaceFile.filePath;
        (0, utils_js_1.assert)(isInterfaceFileUserLand(interfaceFile));
        (0, utils_js_1.assert)(filePathAbsoluteUserRootDir);
        return filePathAbsoluteUserRootDir.length;
    })(interfaceFile1, interfaceFile2);
}
function warnOverridenConfigValues(interfaceFileWinner, interfaceFilesOverriden, configName) {
    interfaceFilesOverriden.forEach((interfaceFileLoser) => {
        const loserFilePath = interfaceFileLoser.filePath.filePathToShowToUser;
        const winnerFilePath = interfaceFileWinner.filePath.filePathToShowToUser;
        const confName = picocolors_1.default.cyan(configName);
        (0, utils_js_1.assertWarning)(false, `The value of the config ${confName} defined at ${loserFilePath} is always overwritten by the value defined at ${winnerFilePath}, remove the superfluous value defined at ${loserFilePath}`, { onlyOnce: true });
    });
}
function isInterfaceFileUserLand(interfaceFile) {
    return (interfaceFile.isConfigFile && !interfaceFile.isConfigExtend) || interfaceFile.isValueFile;
}
async function getConfigValueSource(configName, interfaceFile, configDef, userRootDir, importedFilesLoaded, isHighestInheritancePrecedence) {
    const conf = interfaceFile.fileExportsByConfigName[configName];
    (0, utils_js_1.assert)(conf);
    const configEnv = deriveConfigEnvFromFileName(configDef.env, interfaceFile.filePath.fileName);
    const { locationId } = interfaceFile;
    const definedAtFilePath_ = {
        ...interfaceFile.filePath,
        fileExportPathToShowToUser: ['default', configName]
    };
    const isOverriden = configDef.cumulative ? false : !isHighestInheritancePrecedence;
    // +client.js
    if (configDef._valueIsFilePath) {
        let definedAtFilePath;
        let valueFilePath;
        if (interfaceFile.isConfigFile) {
            const { configValue } = conf;
            const pointerImport = (0, resolvePointerImport_js_1.resolvePointerImportOfConfig)(configValue, interfaceFile.filePath, userRootDir, configEnv, configName);
            const configDefinedAt = (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', configName, definedAtFilePath_);
            (0, utils_js_1.assertUsage)(pointerImport, `${configDefinedAt} should be an import`);
            valueFilePath = pointerImport.filePathAbsoluteVite;
            definedAtFilePath = pointerImport;
        }
        else {
            (0, utils_js_1.assert)(interfaceFile.isValueFile);
            valueFilePath = interfaceFile.filePath.filePathAbsoluteVite;
            definedAtFilePath = {
                ...interfaceFile.filePath,
                fileExportPathToShowToUser: []
            };
        }
        const configValueSource = {
            locationId,
            value: valueFilePath,
            valueIsFilePath: true,
            configEnv,
            valueIsImportedAtRuntime: true,
            valueIsDefinedByPlusFile: false,
            isOverriden,
            definedAtFilePath
        };
        return configValueSource;
    }
    // +config.js
    if (interfaceFile.isConfigFile) {
        (0, utils_js_1.assert)('configValue' in conf);
        const { configValue } = conf;
        // Pointer import
        const pointerImport = (0, resolvePointerImport_js_1.resolvePointerImportOfConfig)(configValue, interfaceFile.filePath, userRootDir, configEnv, configName);
        if (pointerImport) {
            const configValueSource = {
                locationId,
                configEnv,
                valueIsImportedAtRuntime: true,
                valueIsDefinedByPlusFile: false,
                isOverriden,
                definedAtFilePath: pointerImport
            };
            // Load pointer import
            if (isLoadableAtBuildTime(configDef) &&
                // The value of `extends` was already loaded and already used: we don't need the value of `extends` anymore
                configName !== 'extends') {
                if (pointerImport.filePathAbsoluteFilesystem) {
                    const fileExport = await (0, loadFileAtConfigTime_js_1.loadImportedFile)(pointerImport, userRootDir, importedFilesLoaded);
                    configValueSource.value = fileExport;
                }
                else {
                    const configDefinedAt = (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', configName, configValueSource.definedAtFilePath);
                    (0, utils_js_1.assertUsage)(!configDef.cumulative, `${configDefinedAt} cannot be defined over an aliased import`);
                }
            }
            return configValueSource;
        }
        // Defined by config file, i.e. +config.js file
        const configValueSource = {
            locationId,
            value: configValue,
            configEnv,
            valueIsImportedAtRuntime: false,
            valueIsDefinedByPlusFile: false,
            isOverriden,
            definedAtFilePath: definedAtFilePath_
        };
        return configValueSource;
    }
    // Defined by value file, i.e. +{configName}.js
    if (interfaceFile.isValueFile) {
        const valueAlreadyLoaded = 'configValue' in conf;
        (0, utils_js_1.assert)(valueAlreadyLoaded === !!configEnv.config);
        const configValueSource = {
            locationId,
            configEnv,
            valueIsImportedAtRuntime: !valueAlreadyLoaded,
            valueIsDefinedByPlusFile: true,
            isOverriden,
            definedAtFilePath: {
                ...interfaceFile.filePath,
                fileExportPathToShowToUser: configName === interfaceFile.configName
                    ? []
                    : // Side-effect config (e.g. `export { frontmatter }` of .md files)
                        [configName]
            }
        };
        if (valueAlreadyLoaded) {
            configValueSource.value = conf.configValue;
        }
        return configValueSource;
    }
    (0, utils_js_1.assert)(false);
}
function isDefiningPage(interfaceFiles) {
    for (const interfaceFile of interfaceFiles) {
        const configNames = Object.keys(interfaceFile.fileExportsByConfigName);
        if (configNames.some((configName) => isDefiningPageConfig(configName))) {
            return true;
        }
    }
    return false;
}
function isDefiningPageConfig(configName) {
    return ['Page', 'route'].includes(configName);
}
function getConfigDefinitions(interfaceFilesRelevant) {
    const configDefinitionsMerged = { ...configDefinitionsBuiltIn_js_1.configDefinitionsBuiltIn };
    Object.entries(interfaceFilesRelevant)
        .reverse()
        .forEach(([_locationId, interfaceFiles]) => {
        interfaceFiles.forEach((interfaceFile) => {
            const configMeta = interfaceFile.fileExportsByConfigName['meta'];
            if (!configMeta)
                return;
            const meta = configMeta.configValue;
            assertMetaUsage(meta, `Config ${picocolors_1.default.cyan('meta')} defined at ${interfaceFile.filePath.filePathToShowToUser}`);
            // Set configDef._userEffectDefinedAtFilePath
            Object.entries(meta).forEach(([configName, configDef]) => {
                if (!configDef.effect)
                    return;
                (0, utils_js_1.assert)(interfaceFile.isConfigFile);
                configDef._userEffectDefinedAtFilePath = {
                    ...interfaceFile.filePath,
                    fileExportPathToShowToUser: ['default', 'meta', configName, 'effect']
                };
            });
            (0, utils_js_1.objectEntries)(meta).forEach(([configName, configDefinition]) => {
                // User can override an existing config definition
                configDefinitionsMerged[configName] = {
                    ...configDefinitionsMerged[configName],
                    ...configDefinition
                };
            });
        });
    });
    const configDefinitions = configDefinitionsMerged;
    return configDefinitions;
}
function assertMetaUsage(metaVal, metaConfigDefinedAt) {
    if (!(0, utils_js_1.isObject)(metaVal)) {
        (0, utils_js_1.assert)(metaConfigDefinedAt); // We expect internal effects to return a valid meta value
        (0, utils_js_1.assertUsage)(false, `${metaConfigDefinedAt} has an invalid type ${picocolors_1.default.cyan(typeof metaVal)}: it should be an object instead.`);
    }
    (0, utils_js_1.objectEntries)(metaVal).forEach(([configName, def]) => {
        if (!(0, utils_js_1.isObject)(def)) {
            (0, utils_js_1.assert)(metaConfigDefinedAt); // We expect internal effects to return a valid meta value
            (0, utils_js_1.assertUsage)(false, `${metaConfigDefinedAt} sets ${picocolors_1.default.cyan(`meta.${configName}`)} to a value with an invalid type ${picocolors_1.default.cyan(typeof def)}: it should be an object instead.`);
        }
        // env
        let configEnv;
        {
            (0, utils_js_1.assert)(metaConfigDefinedAt); // We expect internal effects to return a valid meta value
            if (!('env' in def)) {
                (0, utils_js_1.assertUsage)(false, `${metaConfigDefinedAt} doesn't set ${picocolors_1.default.cyan(`meta.${configName}.env`)} but it's required.`);
            }
            configEnv = getConfigEnvValue(def.env, `${metaConfigDefinedAt} sets ${picocolors_1.default.cyan(`meta.${configName}.env`)} to`);
            // Overwrite deprecated value with valid value
            // TODO/v1-release: remove once support for the deprecated values is removed
            if (typeof def.env === 'string')
                def.env = configEnv;
        }
        // effect
        if ('effect' in def) {
            if (!(0, utils_js_1.hasProp)(def, 'effect', 'function')) {
                (0, utils_js_1.assert)(metaConfigDefinedAt); // We expect internal effects to return a valid meta value
                (0, utils_js_1.assertUsage)(false, `${metaConfigDefinedAt} sets ${picocolors_1.default.cyan(`meta.${configName}.effect`)} to an invalid type ${picocolors_1.default.cyan(typeof def.effect)}: it should be a function instead`);
            }
            if (!configEnv.config) {
                (0, utils_js_1.assert)(metaConfigDefinedAt); // We expect internal effects to return a valid meta value
                (0, utils_js_1.assertUsage)(false, `${metaConfigDefinedAt} sets ${picocolors_1.default.cyan(`meta.${configName}.effect`)} but it's only supported if meta.${configName}.env has ${picocolors_1.default.cyan('{ config: true }')} (but it's ${picocolors_1.default.cyan(JSON.stringify(configEnv))} instead)`);
            }
        }
    });
}
function applyEffectsAll(configValueSources, configDefinitions) {
    (0, utils_js_1.objectEntries)(configDefinitions).forEach(([configName, configDef]) => {
        if (!configDef.effect)
            return;
        // The value needs to be loaded at config time, that's why we only support effect for configs that are config-only for now.
        // (We could support effect for non config-only by always loading its value at config time, regardless of the config's `env` value.)
        (0, utils_js_1.assertUsage)(configDef.env.config, [
            `Cannot add effect to ${picocolors_1.default.cyan(configName)} because its ${picocolors_1.default.cyan('env')} is ${picocolors_1.default.cyan(JSON.stringify(configDef.env))}: effects can only be added to configs with an ${picocolors_1.default.cyan('env')} with ${picocolors_1.default.cyan('{ config: true }')}.`
        ].join(' '));
        const source = configValueSources[configName]?.[0];
        if (!source)
            return;
        // The config value is eagerly loaded since `configDef.env === 'config-only``
        (0, utils_js_1.assert)('value' in source);
        // Call effect
        const configModFromEffect = configDef.effect({
            configValue: source.value,
            configDefinedAt: (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', configName, source.definedAtFilePath)
        });
        if (!configModFromEffect)
            return;
        (0, utils_js_1.assert)((0, utils_js_1.hasProp)(source, 'value')); // We need to assume that the config value is loaded at build-time
        applyEffect(configModFromEffect, configValueSources, configDef);
    });
}
function applyEffect(configModFromEffect, configValueSources, configDefEffect) {
    const notSupported = `Effects currently only supports modifying the the ${picocolors_1.default.cyan('env')} of a config.`;
    (0, utils_js_1.objectEntries)(configModFromEffect).forEach(([configName, configValue]) => {
        if (configName === 'meta') {
            let configDefinedAt;
            if (configDefEffect._userEffectDefinedAtFilePath) {
                configDefinedAt = (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', configName, configDefEffect._userEffectDefinedAtFilePath);
            }
            else {
                configDefinedAt = null;
            }
            assertMetaUsage(configValue, configDefinedAt);
            (0, utils_js_1.objectEntries)(configValue).forEach(([configTargetName, configTargetDef]) => {
                {
                    const keys = Object.keys(configTargetDef);
                    (0, utils_js_1.assertUsage)(keys.includes('env'), notSupported);
                    (0, utils_js_1.assertUsage)(keys.length === 1, notSupported);
                }
                const envOverriden = configTargetDef.env;
                const sources = configValueSources[configTargetName];
                sources?.forEach((configValueSource) => {
                    // Apply effect
                    configValueSource.configEnv = envOverriden;
                });
            });
        }
        else {
            (0, utils_js_1.assertUsage)(false, notSupported);
            /* To implement being able to set a config value in an effect:
             * - Copy and append definedAtFile.fileExportPathToShowToUser with ['meta', configName, 'effect']
             *   - Copying the definedAtFile of the config that defines the effect
             * - Same precedence as the config that sets the value triggering the effect (not the config defining the effect)
             *   - Apply sortConfigValueSources() again?
            configValueSources.push()
            */
        }
    });
}
function getComputed(configValueSources, configDefinitions) {
    const configValuesComputed = {};
    (0, utils_js_1.objectEntries)(configDefinitions).forEach(([configName, configDef]) => {
        if (!configDef._computed)
            return;
        const value = configDef._computed(configValueSources);
        if (value === undefined)
            return;
        configValuesComputed[configName] = {
            value,
            configEnv: configDef.env
        };
    });
    return configValuesComputed;
}
async function findPlusFiles(userRootDir, outDirRoot, isDev, crawlWithGit) {
    const files = await (0, crawlPlusFiles_js_1.crawlPlusFiles)(userRootDir, outDirRoot, isDev, crawlWithGit);
    const plusFiles = files.map(({ filePathAbsoluteUserRootDir }) => (0, getFilePath_js_1.getFilePathResolved)({ filePathAbsoluteUserRootDir, userRootDir }));
    return plusFiles;
}
function getConfigName(filePath) {
    (0, utils_js_1.assertPosixPath)(filePath);
    if ((0, transpileAndExecuteFile_js_1.isTemporaryBuildFile)(filePath))
        return null;
    const fileName = path_1.default.posix.basename(filePath);
    // assertNoUnexpectedPlusSign(filePath, fileName)
    const basename = fileName.split('.')[0];
    if (!basename.startsWith('+')) {
        return null;
    }
    else {
        const configName = basename.slice(1);
        (0, utils_js_1.assertUsage)(configName !== '', `${filePath} Invalid filename ${fileName}`);
        return configName;
    }
}
/* https://github.com/vikejs/vike/issues/1407
function assertNoUnexpectedPlusSign(filePath: string, fileName: string) {
  const dirs = path.posix.dirname(filePath).split('/')
  dirs.forEach((dir, i) => {
    const dirPath = dirs.slice(0, i + 1).join('/')
    assertUsage(
      !dir.includes('+'),
      `Character '+' is a reserved character: remove '+' from the directory name ${dirPath}/`
    )
  })
  assertUsage(
    !fileName.slice(1).includes('+'),
    `Character '+' is only allowed at the beginning of filenames: make sure ${filePath} doesn't contain any '+' in its filename other than its first letter`
  )
}
*/
function handleUnknownConfig(configName, configNames, filePathToShowToUser) {
    const configNameColored = picocolors_1.default.cyan(configName);
    let errMsg = `${filePathToShowToUser} sets an unknown config ${configNameColored}.`;
    // vike-{react,vue,solid} hint
    {
        const ui = ['vike-react', 'vike-vue', 'vike-solid'];
        const knownVikeExntensionConfigs = {
            description: ui,
            favicon: ui,
            Head: ui,
            Layout: ui,
            onCreateApp: ['vike-vue'],
            title: ui,
            ssr: ui,
            stream: ui,
            Wrapper: ui
        };
        if (configName in knownVikeExntensionConfigs) {
            const requiredVikeExtension = knownVikeExntensionConfigs[configName];
            (0, utils_js_1.assertUsage)(false, [
                errMsg,
                `If you want to use the configuration documented at https://vike.dev/${configName} then make sure to install the Vike extension ${requiredVikeExtension
                    .map((e) => picocolors_1.default.bold(e))
                    .join('/')}.`,
                `Also make sure it applies to ${filePathToShowToUser} (see https://vike.dev/extends#inheritance).`,
                `Alternatively, if you don't want to use the aforementioned Vike extension, define it yourself by using ${picocolors_1.default.cyan('meta')} (https://vike.dev/meta).`
            ].join(' '));
        }
    }
    // Similarity hint
    let configNameSimilar = null;
    if (configName === 'page') {
        configNameSimilar = 'Page';
    }
    else {
        configNameSimilar = (0, utils_js_1.getMostSimilar)(configName, configNames);
    }
    if (configNameSimilar) {
        (0, utils_js_1.assert)(configNameSimilar !== configName);
        errMsg += ` Did you mean to set ${picocolors_1.default.cyan(configNameSimilar)} instead?`;
        if (configName === 'page') {
            errMsg += ` (The name of the config ${picocolors_1.default.cyan('Page')} starts with a capital letter ${picocolors_1.default.cyan('P')} because it defines a UI component: a ubiquitous JavaScript convention is that the name of UI components start with a capital letter.)`;
        }
    }
    // `meta` hint
    if (!configNameSimilar) {
        errMsg += ` Make sure to define ${configNameColored} by using ${picocolors_1.default.cyan('meta')} (https://vike.dev/meta), and also make sure the meta configuration applies to ${filePathToShowToUser} (see https://vike.dev/config#inheritance).`;
    }
    (0, utils_js_1.assertUsage)(false, errMsg);
}
function determineRouteFilesystem(locationId, configValueSources) {
    const configName = 'filesystemRoutingRoot';
    const configFilesystemRoutingRoot = configValueSources[configName]?.[0];
    let filesystemRouteString = (0, filesystemRouting_js_1.getFilesystemRouteString)(locationId);
    if (determineIsErrorPage(filesystemRouteString)) {
        return { isErrorPage: true, routeFilesystem: undefined };
    }
    let filesystemRouteDefinedBy = (0, filesystemRouting_js_1.getFilesystemRouteDefinedBy)(locationId); // for log404()
    if (configFilesystemRoutingRoot) {
        const routingRoot = getFilesystemRoutingRootEffect(configFilesystemRoutingRoot, configName);
        if (routingRoot) {
            const { filesystemRoutingRootEffect /*, filesystemRoutingRootConfigDefinedAt*/ } = routingRoot;
            const debugInfo = { locationId, routeFilesystem: filesystemRouteString, configFilesystemRoutingRoot };
            (0, utils_js_1.assert)(filesystemRouteString.startsWith(filesystemRoutingRootEffect.before), debugInfo);
            filesystemRouteString = (0, filesystemRouting_js_1.applyFilesystemRoutingRootEffect)(filesystemRouteString, filesystemRoutingRootEffect);
            // filesystemRouteDefinedBy = `${filesystemRouteDefinedBy} (with ${filesystemRoutingRootConfigDefinedAt})`
        }
    }
    (0, utils_js_1.assert)(filesystemRouteString.startsWith('/'));
    const routeFilesystem = {
        routeString: filesystemRouteString,
        definedBy: filesystemRouteDefinedBy
    };
    return { routeFilesystem, isErrorPage: undefined };
}
function getFilesystemRoutingRootEffect(configFilesystemRoutingRoot, configName) {
    (0, utils_js_1.assert)(configFilesystemRoutingRoot.configEnv.config);
    // Eagerly loaded since it's config-only
    (0, utils_js_1.assert)('value' in configFilesystemRoutingRoot);
    const { value } = configFilesystemRoutingRoot;
    const configDefinedAt = (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', configName, configFilesystemRoutingRoot.definedAtFilePath);
    (0, utils_js_1.assertUsage)(typeof value === 'string', `${configDefinedAt} should be a string`);
    (0, utils_js_1.assertUsage)(value.startsWith('/'), `${configDefinedAt} is ${picocolors_1.default.cyan(value)} but it should start with a leading slash ${picocolors_1.default.cyan('/')}`);
    const { filePathAbsoluteUserRootDir } = configFilesystemRoutingRoot.definedAtFilePath;
    (0, utils_js_1.assert)(filePathAbsoluteUserRootDir);
    const before = (0, filesystemRouting_js_1.getFilesystemRouteString)((0, filesystemRouting_js_1.getLocationId)(filePathAbsoluteUserRootDir));
    const after = value;
    const filesystemRoutingRootEffect = { before, after };
    return { filesystemRoutingRootEffect, filesystemRoutingRootConfigDefinedAt: configDefinedAt };
}
function determineIsErrorPage(routeFilesystem) {
    (0, utils_js_1.assertPosixPath)(routeFilesystem);
    return routeFilesystem.split('/').includes('_error');
}
function isVikeConfigFile(filePath) {
    return !!getConfigName(filePath);
}
function getConfigEnvValue(val, errMsgIntro) {
    const errInvalidValue = `${errMsgIntro} an invalid value ${picocolors_1.default.cyan(JSON.stringify(val))}`;
    // Legacy outdated values
    // TODO/v1-release: remove
    if (typeof val === 'string') {
        const valConverted = (() => {
            if (val === 'client-only')
                return { client: true };
            if (val === 'server-only')
                return { server: true };
            if (val === 'server-and-client')
                return { server: true, client: true };
            if (val === 'config-only')
                return { config: true };
            if (val === '_routing-lazy')
                return { server: true, client: 'if-client-routing' };
            if (val === '_routing-eager')
                return { server: true, client: 'if-client-routing', eager: true };
            (0, utils_js_1.assertUsage)(false, errInvalidValue);
        })();
        (0, utils_js_1.assertWarning)(false, `${errMsgIntro} ${picocolors_1.default.cyan(val)} which is deprecated and will be removed in the next major release`, { onlyOnce: true });
        return valConverted;
    }
    (0, utils_js_1.assertUsage)((0, utils_js_1.isObject)(val), `${errMsgIntro} an invalid type ${picocolors_1.default.cyan(typeof val)}`);
    (0, utils_js_1.assertKeys)(val, ['config', 'server', 'client'], `${errInvalidValue}:`);
    (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(val, 'config', 'undefined') || (0, utils_js_1.hasProp)(val, 'config', 'boolean'), errInvalidValue);
    (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(val, 'server', 'undefined') || (0, utils_js_1.hasProp)(val, 'server', 'boolean'), errInvalidValue);
    (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(val, 'client', 'undefined') || (0, utils_js_1.hasProp)(val, 'client', 'boolean'), errInvalidValue);
    /* To allow users to set an eager config:
     * - Uncomment line below.
     * - Add 'eager' to assertKeys() call above.
     * - Add `eager: boolean` to ConfigEnv type.
    assertUsage(hasProp(val, 'eager', 'undefined') || hasProp(val, 'eager', 'boolean'), errInvalidValue)
    */
    return val;
}
function getConfigDefinition(configDefinitions, configName, filePathToShowToUser) {
    const configDef = configDefinitions[configName];
    assertConfigExists(configName, Object.keys(configDefinitions), filePathToShowToUser);
    (0, utils_js_1.assert)(configDef);
    return configDef;
}
function getConfigDefinitionOptional(configDefinitions, configName) {
    return configDefinitions[configName] ?? null;
}
function isLoadableAtBuildTime(configDef) {
    return !!configDef.env.config && !configDef._valueIsFilePath;
}
function isGlobalConfig(configName) {
    if (configName === 'prerender')
        return false;
    const configNamesGlobal = getConfigNamesGlobal();
    return (0, utils_js_1.includes)(configNamesGlobal, configName);
}
function getConfigNamesGlobal() {
    return Object.keys(configDefinitionsBuiltIn_js_1.configDefinitionsBuiltInGlobal);
}
function assertConfigExists(configName, configNamesRelevant, filePathToShowToUser) {
    const configNames = [...configNamesRelevant, ...getConfigNamesGlobal()];
    if (configNames.includes(configName))
        return;
    handleUnknownConfig(configName, configNames, filePathToShowToUser);
    (0, utils_js_1.assert)(false);
}
function sortConfigValueSources(configValueSources, locationIdPage) {
    return Object.fromEntries(Object.entries(configValueSources)
        // Make order deterministic (no other purpose)
        .sort(([, [source1]], [, [source2]]) => source1.definedAtFilePath.filePathAbsoluteVite < source2.definedAtFilePath.filePathAbsoluteVite ? -1 : 1)
        // Sort after whether the config value was defined by an npm package
        .sort((0, utils_js_1.makeFirst)(([, [source]]) => {
        const { importPathAbsolute } = source.definedAtFilePath;
        return (!!importPathAbsolute &&
            (0, utils_js_1.isNpmPackageImport)(importPathAbsolute, {
                // Vike config files don't support path aliases. (If they do one day, then Vike will/should be able to resolve path aliases.)
                cannotBePathAlias: true
            }));
    }))
        // Sort after the filesystem inheritance of the config value
        .sort(([, [source1]], [, [source2]]) => (0, utils_js_1.reverse)((0, filesystemRouting_js_1.sortAfterInheritanceOrder)(source1.locationId, source2.locationId, locationIdPage))));
}
function getConfigValueInterfaceFile(interfaceFile, configName) {
    return interfaceFile.fileExportsByConfigName[configName]?.configValue;
}
