"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importUserCode = importUserCode;
const vite_1 = require("vite");
const getConfigVike_js_1 = require("../../../shared/getConfigVike.js");
const getVirtualFilePageConfigValuesAll_js_1 = require("./v1-design/getVirtualFilePageConfigValuesAll.js");
const getVirtualFileImportUserCode_js_1 = require("./getVirtualFileImportUserCode.js");
const utils_js_1 = require("../../utils.js");
const virtualFilePageConfigValuesAll_js_1 = require("../../../shared/virtual-files/virtualFilePageConfigValuesAll.js");
const virtualFileImportUserCode_js_1 = require("../../../shared/virtual-files/virtualFileImportUserCode.js");
const getVikeConfig_js_1 = require("./v1-design/getVikeConfig.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const loggerNotProd_js_1 = require("../../shared/loggerNotProd.js");
const getFilePath_js_1 = require("../../shared/getFilePath.js");
function importUserCode() {
    let config;
    let configVike;
    let isDev;
    return {
        name: 'vike:importUserCode',
        config(_, env) {
            isDev = (0, utils_js_1.isDev3)(env);
        },
        async configResolved(config_) {
            configVike = await (0, getConfigVike_js_1.getConfigVike)(config_);
            config = config_;
            // TODO/v1-release: remove
            {
                (0, utils_js_1.assert)(isDev !== undefined);
                const isV1 = await (0, getVikeConfig_js_1.isV1Design)(config, isDev);
                if (!isV1)
                    config.experimental.importGlobRestoreExtension = true;
            }
        },
        resolveId(id) {
            if ((0, utils_js_1.isVirtualFileId)(id)) {
                return (0, utils_js_1.resolveVirtualFileId)(id);
            }
        },
        handleHotUpdate(ctx) {
            try {
                return handleHotUpdate(ctx, config);
            }
            catch (err) {
                // Vite swallows errors thrown by handleHotUpdate()
                console.error(err);
                throw err;
            }
        },
        async load(id, options) {
            if (!(0, utils_js_1.isVirtualFileId)(id))
                return undefined;
            id = (0, utils_js_1.getVirtualFileId)(id);
            (0, utils_js_1.assert)(typeof isDev === 'boolean');
            if ((0, virtualFilePageConfigValuesAll_js_1.isVirtualFileIdPageConfigValuesAll)(id)) {
                const code = await (0, getVirtualFilePageConfigValuesAll_js_1.getVirtualFilePageConfigValuesAll)(id, isDev, config);
                return code;
            }
            if ((0, virtualFileImportUserCode_js_1.isVirtualFileIdImportUserCode)(id)) {
                const code = await (0, getVirtualFileImportUserCode_js_1.getVirtualFileImportUserCode)(id, options, configVike, config, isDev);
                return code;
            }
        },
        configureServer(server) {
            handleFileAddRemove(server, config);
        }
    };
}
function handleFileAddRemove(server, config) {
    server.watcher.prependListener('add', (f) => listener(f, false));
    server.watcher.prependListener('unlink', (f) => listener(f, true));
    return;
    function listener(file, isRemove) {
        file = (0, vite_1.normalizePath)(file);
        const isVikeConfig = isVikeConfigModule(file) || (0, getVikeConfig_js_1.isVikeConfigFile)(file);
        if (isVikeConfig) {
            const virtualModules = getVirtualModules(server);
            virtualModules.forEach((mod) => {
                server.moduleGraph.invalidateModule(mod);
            });
            reloadConfig(file, config, isRemove ? 'removed' : 'created');
        }
    }
}
function handleHotUpdate(ctx, config) {
    const { file, server } = ctx;
    (0, utils_js_1.assertPosixPath)(file);
    getVikeConfig_js_1.vikeConfigDependencies.forEach((f) => (0, utils_js_1.assertPosixPath)(f));
    const isVikeConfig = isVikeConfigModule(file);
    const isViteModule = ctx.modules.length > 0;
    /* Should we show this?
    // - Can be useful for server files that aren't processed by Vite.
    // - Can be annoying for files that obviously aren't processed by Vite.
    if (!isVikeConfig && !isViteModule) {
      logViteAny(
        `${msg} â€” ${pc.cyan('no HMR')}, see https://vike.dev/on-demand-compiler`,
        'info',
        null,
        true
      )
      return
    }
    //*/
    // It can hide an error it shouldn't hide (because the error isn't shown again), but it's ok since users can reload the page and the error will be shown again (Vite transpilation errors are shown again upon a page reload).
    if (!isVikeConfig && isViteModule) {
        return;
    }
    if (isVikeConfig) {
        /* Tailwind breaks this assertion, see https://github.com/vikejs/vike/discussions/1330#discussioncomment-7787238
        assert(!isViteModule)
        */
        reloadConfig(file, config, 'modified');
        const virtualModules = getVirtualModules(server);
        return virtualModules;
    }
}
function isVikeConfigModule(filePathAbsoluteFilesystem) {
    return getVikeConfig_js_1.vikeConfigDependencies.has(filePathAbsoluteFilesystem);
}
function reloadConfig(filePath, config, op) {
    {
        const filePathToShowToUserResolved = (0, getFilePath_js_1.getModuleFilePathAbsolute)(filePath, config);
        const msg = `${op} ${picocolors_1.default.dim(filePathToShowToUserResolved)}`;
        (0, loggerNotProd_js_1.logConfigInfo)(msg, 'info');
    }
    (0, getVikeConfig_js_1.reloadVikeConfig)(config.root, (0, utils_js_1.getOutDirs)(config).outDirRoot);
}
function getVirtualModules(server) {
    const virtualModules = Array.from(server.moduleGraph.urlToModuleMap.keys())
        .filter((url) => (0, virtualFilePageConfigValuesAll_js_1.isVirtualFileIdPageConfigValuesAll)(url) || (0, virtualFileImportUserCode_js_1.isVirtualFileIdImportUserCode)(url))
        .map((url) => {
        const mod = server.moduleGraph.urlToModuleMap.get(url);
        (0, utils_js_1.assert)(mod);
        return mod;
    });
    return virtualModules;
}
