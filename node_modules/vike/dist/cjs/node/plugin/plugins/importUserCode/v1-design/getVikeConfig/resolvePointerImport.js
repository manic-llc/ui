"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePointerImportOfConfig = resolvePointerImportOfConfig;
exports.resolvePointerImport = resolvePointerImport;
exports.clearFilesEnvMap = clearFilesEnvMap;
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const utils_js_1 = require("../../../../utils.js");
const transformPointerImports_js_1 = require("./transformPointerImports.js");
const path_1 = __importDefault(require("path"));
const getFilePath_js_1 = require("../../../../shared/getFilePath.js");
const filesEnvMap = new Map();
function resolvePointerImportOfConfig(configValue, importerFilePath, userRootDir, configEnv, configName) {
    if (typeof configValue !== 'string')
        return null;
    const pointerImportData = (0, transformPointerImports_js_1.parsePointerImportData)(configValue);
    if (!pointerImportData)
        return null;
    const { importPath, exportName } = pointerImportData;
    const filePath = resolvePointerImport(pointerImportData, importerFilePath, userRootDir);
    const fileExportPathToShowToUser = exportName === 'default' || exportName === configName ? [] : [exportName];
    assertUsageFileEnv(filePath.filePathAbsoluteFilesystem, importPath, configEnv, configName);
    return {
        ...filePath,
        fileExportName: exportName,
        fileExportPathToShowToUser
    };
}
function resolvePointerImport(pointerImportData, importerFilePath, userRootDir) {
    // `importPath` should be one of the following:
    // - A relative import path
    // - A filesystem absolute path
    // - An npm package import
    const { importPath } = pointerImportData;
    const filePathAbsoluteFilesystem = resolveImportPathWithNode(pointerImportData, importerFilePath);
    let filePath;
    (0, utils_js_1.assertPosixPath)(importPath);
    if (importPath.startsWith('.') || (0, utils_js_1.isFilePathAbsolute)(importPath)) {
        if (importPath.startsWith('.')) {
            (0, utils_js_1.assertUsage)(importPath.startsWith('./') || importPath.startsWith('../'), `Invalid relative import path ${picocolors_1.default.code(importPath)} defined by ${importerFilePath.filePathToShowToUser} because it should start with ${picocolors_1.default.code('./')} or ${picocolors_1.default.code('../')}, or use an npm package import instead.`);
        }
        // Pointer imports are included in virtual files, thus relative imports need to be resolved. (Virtual modules cannot contain relative imports.)
        assertUsageResolutionSuccess(filePathAbsoluteFilesystem, pointerImportData, importerFilePath);
        // Pointer imports are included in virtual files, and we need filePathAbsoluteUserRootDir because we didn't find a way to have filesystem absolute import paths in virtual files: https://gist.github.com/brillout/2315231c9a8164f950c64b4b4a7bbd39
        const errSuffix = `outside of the ${userRootDir} directory which is forbidden: make sure your import paths resolve inside the ${userRootDir} directory, or import from an npm package.`;
        const filePathAbsoluteUserRootDir = (0, getFilePath_js_1.getFilePathAbsoluteUserRootDir)({ filePathAbsoluteFilesystem, userRootDir });
        if (importPath.startsWith('.')) {
            (0, utils_js_1.assertUsage)(filePathAbsoluteUserRootDir, `The relative import ${picocolors_1.default.cyan(importPath)} defined by ${importerFilePath.filePathToShowToUser} resolves to ${filePathAbsoluteFilesystem} ${errSuffix}`);
        }
        else {
            (0, utils_js_1.assert)((0, utils_js_1.isFilePathAbsolute)(importPath));
            (0, utils_js_1.assertUsage)(filePathAbsoluteUserRootDir, `The import path ${importPath} defined by ${importerFilePath.filePathToShowToUser} is ${errSuffix}`);
        }
        // Forbid node_modules/ because it's brittle: if node_modules/ lives outside of userRootDir then it crashes.
        (0, utils_js_1.assertUsage)(!filePathAbsoluteUserRootDir.includes('/node_modules/'), `The import path ${importPath} defined by ${importerFilePath.filePathToShowToUser} resolves to ${filePathAbsoluteFilesystem} inside of node_modules/ which is forbbiden: use an npm package import instead.`);
        filePath = (0, getFilePath_js_1.getFilePathResolved)({ filePathAbsoluteUserRootDir, userRootDir });
    }
    else {
        const importPathAbsolute = importPath;
        if (filePathAbsoluteFilesystem) {
            filePath = (0, getFilePath_js_1.getFilePathResolved)({
                userRootDir,
                filePathAbsoluteFilesystem,
                importPathAbsolute
            });
        }
        else {
            filePath = (0, getFilePath_js_1.getFilePathUnresolved)({
                importPathAbsolute
            });
        }
    }
    return filePath;
}
function resolveImportPathWithNode(pointerImportData, importerFilePath) {
    const importerFilePathAbsolute = importerFilePath.filePathAbsoluteFilesystem;
    (0, utils_js_1.assertPosixPath)(importerFilePathAbsolute);
    const cwd = path_1.default.posix.dirname(importerFilePathAbsolute);
    // We still can't use import.meta.resolve() as of 23.1.0 (November 2024) because `parent` argument requires an experimental flag.
    // - https://stackoverflow.com/questions/54977743/do-require-resolve-for-es-modules#comment139581675_62272600
    // filePathAbsoluteFilesystem is expected to be null when pointerImportData.importPath is a Vite path alias
    const filePathAbsoluteFilesystem = (0, utils_js_1.requireResolve)(pointerImportData.importPath, cwd);
    return filePathAbsoluteFilesystem;
}
function assertUsageResolutionSuccess(filePathAbsoluteFilesystem, pointerImportData, importerFilePath) {
    const { importPath: importPath, importStringWasGenerated, importString } = pointerImportData;
    const { filePathToShowToUser } = importerFilePath;
    if (!filePathAbsoluteFilesystem) {
        const importPathString = picocolors_1.default.code(`${importPath}`);
        const errIntro = importStringWasGenerated
            ? `The import path ${importPathString} in ${filePathToShowToUser}`
            : `The import ${picocolors_1.default.code(importString)} defined by ${filePathToShowToUser}`;
        const errIntro2 = `${errIntro} couldn't be resolved: does ${importPathString}`;
        if (importPath.startsWith('.')) {
            (0, utils_js_1.assert)(importPath.startsWith('./') || importPath.startsWith('../'));
            (0, utils_js_1.assertUsage)(false, `${errIntro2} point to an existing file?`);
        }
        else {
            (0, utils_js_1.assertUsage)(false, `${errIntro2} exist?`);
        }
    }
}
function assertUsageFileEnv(filePathAbsoluteFilesystem, importPath, configEnv, configName) {
    let key;
    if (filePathAbsoluteFilesystem) {
        key = filePathAbsoluteFilesystem;
    }
    else {
        (0, utils_js_1.assertIsNpmPackageImport)(importPath);
        key = importPath;
    }
    (0, utils_js_1.assertPosixPath)(key);
    if (!filesEnvMap.has(key)) {
        filesEnvMap.set(key, []);
    }
    const fileEnv = filesEnvMap.get(key);
    fileEnv.push({ configEnv, configName });
    const configDifferentEnv = fileEnv.filter((c) => !(0, utils_js_1.deepEqual)(c.configEnv, configEnv))[0];
    if (configDifferentEnv) {
        (0, utils_js_1.assertUsage)(false, [
            `${key} defines the value of configs living in different environments:`,
            ...[configDifferentEnv, { configName, configEnv }].map((c) => `  - config ${picocolors_1.default.code(c.configName)} which value lives in environment ${picocolors_1.default.code(JSON.stringify(c.configEnv))}`),
            'Defining config values in the same file is allowed only if they live in the same environment, see https://vike.dev/config#pointer-imports'
        ].join('\n'));
    }
}
function clearFilesEnvMap() {
    filesEnvMap.clear();
}
