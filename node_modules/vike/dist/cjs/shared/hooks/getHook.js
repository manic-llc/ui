"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHook = getHook;
exports.getHookFromPageConfig = getHookFromPageConfig;
exports.getHookFromPageConfigGlobal = getHookFromPageConfigGlobal;
exports.assertHook = assertHook;
exports.getHook_setIsPrerenderering = getHook_setIsPrerenderering;
exports.getHookTimeoutDefault = getHookTimeoutDefault;
const getGlobalObject_js_1 = require("../../utils/getGlobalObject.js");
const helpers_js_1 = require("../page-configs/helpers.js");
const getConfigValue_js_1 = require("../page-configs/getConfigValue.js");
const utils_js_1 = require("../utils.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const globalObject = (0, getGlobalObject_js_1.getGlobalObject)('getHook.ts', {});
function getHook(pageContext, hookName) {
    if (!(hookName in pageContext.exports)) {
        return null;
    }
    const { hooksTimeout } = pageContext.config;
    const hookTimeout = getHookTimeout(hooksTimeout, hookName);
    const hookFn = pageContext.exports[hookName];
    const file = pageContext.exportsAll[hookName][0];
    (0, utils_js_1.assert)(file.exportValue === hookFn);
    if (hookFn === null)
        return null;
    const hookFilePath = file.filePath;
    (0, utils_js_1.assert)(hookFilePath);
    (0, utils_js_1.assert)(!hookFilePath.endsWith(' '));
    assertHookFn(hookFn, { hookName, hookFilePath });
    return { hookFn, hookName, hookFilePath, hookTimeout };
}
function getHookFromPageConfig(pageConfig, hookName) {
    const configValue = (0, getConfigValue_js_1.getConfigValueRuntime)(pageConfig, hookName);
    const hooksTimeout = (0, getConfigValue_js_1.getConfigValueRuntime)(pageConfig, 'hooksTimeout')?.value;
    if (!configValue)
        return null;
    const hookFn = configValue.value;
    if (!hookFn)
        return null;
    const hookFilePath = (0, helpers_js_1.getHookFilePathToShowToUser)(configValue.definedAtData);
    // hook isn't a computed nor a cumulative config => hookFilePath should always be defined
    (0, utils_js_1.assert)(hookFilePath);
    assertHookFn(hookFn, { hookName, hookFilePath });
    const hookTimeout = getHookTimeout(hooksTimeout, hookName);
    return { hookFn, hookName, hookFilePath, hookTimeout };
}
function getHookFromPageConfigGlobal(pageConfigGlobal, hookName) {
    const configValue = pageConfigGlobal.configValues[hookName];
    if (!configValue)
        return null;
    const hookFn = configValue.value;
    if (!hookFn)
        return null;
    const hookFilePath = (0, helpers_js_1.getHookFilePathToShowToUser)(configValue.definedAtData);
    // hook isn't a computed nor a cumulative config => hookFilePath should always be defined
    (0, utils_js_1.assert)(hookFilePath);
    assertHookFn(hookFn, { hookName, hookFilePath });
    // We could use the global value of configooksTimeout but it requires some non-trivial refactoring
    const hookTimeout = getHookTimeoutDefault(hookName);
    return { hookFn, hookName, hookFilePath, hookTimeout };
}
function assertHook(pageContext, hookName) {
    getHook(pageContext, hookName);
}
function assertHookFn(hookFn, { hookName, hookFilePath }) {
    (0, utils_js_1.assert)(hookName && hookFilePath);
    (0, utils_js_1.assert)(!hookName.endsWith(')'));
    (0, utils_js_1.assertUsage)((0, utils_js_1.isCallable)(hookFn), `Hook ${hookName}() defined by ${hookFilePath} should be a function`);
    (0, utils_js_1.checkType)(hookFn);
}
function getHookTimeout(hooksTimeoutProvidedByUser, hookName) {
    const hooksTimeoutProvidedbyUserNormalized = getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser);
    if (hooksTimeoutProvidedbyUserNormalized === false)
        return { error: false, warning: false };
    const providedbyUser = hooksTimeoutProvidedbyUserNormalized[hookName];
    const hookTimeout = getHookTimeoutDefault(hookName);
    if (providedbyUser?.error !== undefined)
        hookTimeout.error = providedbyUser.error;
    if (providedbyUser?.warning !== undefined)
        hookTimeout.warning = providedbyUser.warning;
    return hookTimeout;
}
// Ideally this should be called only once and at build-time (to avoid bloating the client-side bundle), but we didn't implement any mechanism to valide config values at build-time yet
function getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser) {
    if (hooksTimeoutProvidedByUser === undefined)
        return {};
    if (hooksTimeoutProvidedByUser === false)
        return false;
    (0, utils_js_1.assertUsage)((0, utils_js_1.isObject)(hooksTimeoutProvidedByUser), `Setting ${picocolors_1.default.cyan('hooksTimeout')} should be ${picocolors_1.default.cyan('false')} or an object`);
    const hooksTimeoutProvidedByUserNormalized = {};
    Object.entries(hooksTimeoutProvidedByUser).forEach(([hookName, hookTimeoutProvidedbyUser]) => {
        if (hookTimeoutProvidedbyUser === false) {
            hooksTimeoutProvidedByUserNormalized[hookName] = { error: false, warning: false };
            return;
        }
        (0, utils_js_1.assertUsage)((0, utils_js_1.isObject)(hookTimeoutProvidedbyUser), `Setting ${picocolors_1.default.cyan(`hooksTimeout.${hookName}`)} should be ${picocolors_1.default.cyan('false')} or an object`);
        const [error, warning] = ['error', 'warning'].map((timeoutName) => {
            const timeoutVal = hookTimeoutProvidedbyUser[timeoutName];
            if (timeoutVal === undefined || timeoutVal === false)
                return timeoutVal;
            const errPrefix = `Setting ${picocolors_1.default.cyan(`hooksTimeout.${hookName}.${timeoutName}`)} should be`;
            (0, utils_js_1.assertUsage)(typeof timeoutVal === 'number', `${errPrefix} ${picocolors_1.default.cyan('false')} or a number`);
            (0, utils_js_1.assertUsage)(timeoutVal > 0, `${errPrefix} a positive number`);
            return timeoutVal;
        });
        hooksTimeoutProvidedByUserNormalized[hookName] = { error, warning };
    });
    return hooksTimeoutProvidedByUserNormalized;
}
function getHookTimeoutDefault(hookName) {
    if (hookName === 'onBeforeRoute') {
        return {
            error: 5 * 1000,
            warning: 1 * 1000
        };
    }
    if (globalObject.isPrerendering) {
        return {
            error: 2 * 60 * 1000,
            warning: 30 * 1000
        };
    }
    else {
        (0, utils_js_1.assert)(!hookName.toLowerCase().includes('prerender'));
    }
    return {
        error: 30 * 1000,
        warning: 4 * 1000
    };
}
function getHook_setIsPrerenderering() {
    globalObject.isPrerendering = true;
}
