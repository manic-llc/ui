export { renderPage };
export { renderPage_addWrapper };
import { getRenderContext, getPageContextInitEnhanced, renderPageAlreadyRouted } from './renderPage/renderPageAlreadyRouted.js';
import { route } from '../../shared/route/index.js';
import { assert, hasProp, objectAssign, isUrl, parseUrl, assertEnv, assertWarning, getGlobalObject, checkType, assertUsage, normalizeUrlPathname, removeBaseServer, modifyUrlPathname, prependBase, removeUrlOrigin, setUrlOrigin, createUrlFromComponents, isUri, getUrlPretty } from './utils.js';
import { assertNoInfiniteAbortLoop, getPageContextFromAllRewrites, isAbortError, logAbortErrorHandled } from '../../shared/route/abort.js';
import { getGlobalContext, initGlobalContext_renderPage } from './globalContext.js';
import { handlePageContextRequestUrl } from './renderPage/handlePageContextRequestUrl.js';
import { createHttpResponseFavicon404, createHttpResponseRedirect, createHttpResponsePageContextJson, createHttpResponseError } from './renderPage/createHttpResponse.js';
import { logRuntimeError, logRuntimeInfo } from './renderPage/loggerRuntime.js';
import { isNewError } from './renderPage/isNewError.js';
import { assertArguments } from './renderPage/assertArguments.js';
import { log404 } from './renderPage/log404/index.js';
import { isConfigInvalid } from './renderPage/isConfigInvalid.js';
import pc from '@brillout/picocolors';
import { serializePageContextAbort, serializePageContextClientSide } from './html/serializePageContextClientSide.js';
import { getErrorPageId } from '../../shared/error-page.js';
import { handleErrorWithoutErrorPage } from './renderPage/handleErrorWithoutErrorPage.js';
import { loadUserFilesServerSide } from './renderPage/loadUserFilesServerSide.js';
import { resolveRedirects } from './renderPage/resolveRedirects.js';
const globalObject = getGlobalObject('runtime/renderPage.ts', {
    httpRequestsCount: 0
});
let renderPage_wrapper = async (_httpRequestId, ret) => ({
    pageContextReturn: await ret()
});
const renderPage_addWrapper = (wrapper) => {
    renderPage_wrapper = wrapper;
};
// `renderPage()` calls `renderPageNominal()` while ensuring that errors are `console.error(err)` instead of `throw err`, so that Vike never triggers a server shut down. (Throwing an error in an Express.js middleware shuts down the whole Express.js server.)
async function renderPage(pageContextInit) {
    assertArguments(...arguments);
    assert(hasProp(pageContextInit, 'urlOriginal', 'string')); // assertUsage() already implemented at assertArguments()
    assertEnv();
    assertIsUrl(pageContextInit.urlOriginal);
    const urlPathnameWithBase = parseUrl(pageContextInit.urlOriginal, '/').pathname;
    assertIsNotViteRequest(urlPathnameWithBase, pageContextInit.urlOriginal);
    if (urlPathnameWithBase.endsWith('/favicon.ico'))
        return getPageContextHttpResponseFavicon404(pageContextInit);
    const httpRequestId = getRequestId();
    const urlOriginalPretty = getUrlPretty(pageContextInit.urlOriginal);
    logHttpRequest(urlOriginalPretty, httpRequestId);
    const { pageContextReturn } = await renderPage_wrapper(httpRequestId, () => renderPageAndPrepare(pageContextInit, httpRequestId));
    logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn);
    checkType(pageContextReturn);
    assert(pageContextReturn.httpResponse);
    return pageContextReturn;
}
async function renderPageAndPrepare(pageContextInit, httpRequestId) {
    // Invalid config
    const handleInvalidConfig = (err) => {
        logRuntimeInfo?.(pc.bold(pc.red('Error while loading a Vike config file, see error above.')), httpRequestId, 'error');
        const pageContextWithError = getPageContextHttpResponseError(err, pageContextInit, null);
        return pageContextWithError;
    };
    if (isConfigInvalid) {
        if (1 < 2 // Make TS happy
        ) {
            return handleInvalidConfig(isConfigInvalid.err);
        }
    }
    // Prepare context
    let renderContext;
    try {
        await initGlobalContext_renderPage();
        renderContext = await getRenderContext();
    }
    catch (err) {
        // Errors are expected since assertUsage() is used in both initGlobalContext_renderPage() and getRenderContext().
        // initGlobalContext_renderPage() and getRenderContext() don't call any user hooks => err isn't thrown from user code.
        assert(!isAbortError(err));
        logRuntimeError(err, httpRequestId);
        const pageContextWithError = getPageContextHttpResponseError(err, pageContextInit, null);
        return pageContextWithError;
    }
    if (isConfigInvalid) {
        return handleInvalidConfig(isConfigInvalid.err);
    }
    else {
        // From now on, renderContext.pageConfigs contains all the configuration data; getVikeConfig() isn't called anymore for this request
    }
    // Check Base URL
    assertBaseUrl(pageContextInit);
    // Normalize URL
    {
        const pageContextHttpResponse = normalizeUrl(pageContextInit, httpRequestId);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    // Permanent redirects (HTTP status code `301`)
    {
        const pageContextHttpResponse = getPermanentRedirect(pageContextInit, httpRequestId);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    return await renderPageAlreadyPrepared(pageContextInit, httpRequestId, renderContext, []);
}
async function renderPageAlreadyPrepared(pageContextInit, httpRequestId, renderContext, pageContextsFromRewrite) {
    assertNoInfiniteAbortLoop(pageContextsFromRewrite.length, 
    // There doesn't seem to be a way to count the number of HTTP redirects (vike don't have access to the HTTP request headers/cookies)
    // https://stackoverflow.com/questions/9683007/detect-infinite-http-redirect-loop-on-server-side
    0);
    let pageContextNominalPageSuccess;
    let pageContextNominalPageInit = {};
    {
        const pageContextFromAllRewrites = getPageContextFromAllRewrites(pageContextsFromRewrite);
        objectAssign(pageContextNominalPageInit, pageContextFromAllRewrites);
    }
    {
        const pageContextInitEnhanced = getPageContextInitEnhancedSSR(pageContextInit, renderContext, pageContextNominalPageInit._urlRewrite, httpRequestId);
        objectAssign(pageContextNominalPageInit, pageContextInitEnhanced);
    }
    let errNominalPage;
    {
        try {
            pageContextNominalPageSuccess = await renderPageNominal(pageContextNominalPageInit);
        }
        catch (err) {
            errNominalPage = err;
            assert(errNominalPage);
            logRuntimeError(errNominalPage, httpRequestId);
        }
        if (!errNominalPage) {
            assert(pageContextNominalPageSuccess === pageContextNominalPageInit);
        }
    }
    // Log upon 404
    if (pageContextNominalPageSuccess &&
        'is404' in pageContextNominalPageSuccess &&
        pageContextNominalPageSuccess.is404 === true) {
        await log404(pageContextNominalPageSuccess);
    }
    if (errNominalPage === undefined) {
        assert(pageContextNominalPageSuccess);
        return pageContextNominalPageSuccess;
    }
    else {
        assert(errNominalPage);
        assert(pageContextNominalPageSuccess === undefined);
        assert(pageContextNominalPageInit);
        assert(hasProp(pageContextNominalPageInit, 'urlOriginal', 'string'));
        const pageContextErrorPageInit = await getPageContextErrorPageInit(pageContextInit, errNominalPage, pageContextNominalPageInit, renderContext, httpRequestId);
        // Handle `throw redirect()` and `throw render()` while rendering nominal page
        if (isAbortError(errNominalPage)) {
            const handled = await handleAbortError(errNominalPage, pageContextsFromRewrite, pageContextInit, pageContextNominalPageInit, httpRequestId, renderContext, pageContextErrorPageInit);
            if (handled.pageContextReturn) {
                // - throw redirect()
                // - throw render(url)
                // - throw render(abortStatusCode) if .pageContext.json request
                return handled.pageContextReturn;
            }
            else {
                // - throw render(abortStatusCode) if not .pageContext.json request
            }
            Object.assign(pageContextErrorPageInit, handled.pageContextAbort);
        }
        {
            const errorPageId = getErrorPageId(renderContext.pageFilesAll, renderContext.pageConfigs);
            if (!errorPageId) {
                objectAssign(pageContextErrorPageInit, { pageId: null });
                return handleErrorWithoutErrorPage(pageContextErrorPageInit);
            }
            else {
                objectAssign(pageContextErrorPageInit, { pageId: errorPageId });
            }
        }
        let pageContextErrorPage;
        try {
            pageContextErrorPage = await renderPageAlreadyRouted(pageContextErrorPageInit);
        }
        catch (errErrorPage) {
            // Handle `throw redirect()` and `throw render()` while rendering error page
            if (isAbortError(errErrorPage)) {
                const handled = await handleAbortError(errErrorPage, pageContextsFromRewrite, pageContextInit, pageContextNominalPageInit, httpRequestId, renderContext, pageContextErrorPageInit);
                // throw render(abortStatusCode)
                if (!handled.pageContextReturn) {
                    const pageContextAbort = errErrorPage._pageContextAbort;
                    assertWarning(false, `Failed to render error page because ${pc.cyan(pageContextAbort._abortCall)} was called: make sure ${pc.cyan(pageContextAbort._abortCaller)} doesn't occur while the error page is being rendered.`, { onlyOnce: false });
                    const pageContextHttpWithError = getPageContextHttpResponseError(errNominalPage, pageContextInit, pageContextErrorPageInit);
                    return pageContextHttpWithError;
                }
                // `throw redirect()` / `throw render(url)`
                return handled.pageContextReturn;
            }
            if (isNewError(errErrorPage, errNominalPage)) {
                logRuntimeError(errErrorPage, httpRequestId);
            }
            const pageContextWithError = getPageContextHttpResponseError(errNominalPage, pageContextInit, pageContextErrorPageInit);
            return pageContextWithError;
        }
        return pageContextErrorPage;
    }
}
function logHttpRequest(urlOriginal, httpRequestId) {
    logRuntimeInfo?.(getRequestInfoMessage(urlOriginal), httpRequestId, 'info');
}
function getRequestInfoMessage(urlOriginal) {
    return `HTTP request: ${prettyUrl(urlOriginal)}`;
}
function logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn) {
    const statusCode = pageContextReturn.httpResponse?.statusCode ?? null;
    let msg;
    let isNominal;
    {
        const { errorWhileRendering } = pageContextReturn;
        const isSkipped = statusCode === null && !errorWhileRendering;
        if (isSkipped) {
            // - URL doesn't include Base URL
            //   - Can we abort earlier so that `logHttpResponse()` and `logHttpRequest()` aren't even called?
            // - Error loading a Vike config file
            //   - We should show `HTTP response ${urlOriginalPretty} ERR` instead.
            //   - Maybe we can/should make the error available at pageContext.errorWhileRendering
            assert(errorWhileRendering === null || errorWhileRendering === undefined);
            msg = `HTTP response ${prettyUrl(urlOriginalPretty)} ${pc.dim('null')}`;
            // Erroneous value (it shoud sometimes be `false`) but it's fine as it doesn't seem to have much of an impact.
            isNominal = true;
        }
        else {
            const isSuccess = statusCode !== null && statusCode >= 200 && statusCode <= 399;
            isNominal = isSuccess || statusCode === 404;
            const color = (s) => pc.bold(isSuccess ? pc.green(String(s)) : pc.red(String(s)));
            const isRedirect = statusCode && 300 <= statusCode && statusCode <= 399;
            const type = isRedirect ? 'redirect' : 'response';
            if (isRedirect) {
                assert(pageContextReturn.httpResponse);
                const headerRedirect = pageContextReturn.httpResponse.headers
                    .slice()
                    .reverse()
                    .find((header) => header[0] === 'Location');
                assert(headerRedirect);
                const urlRedirect = headerRedirect[1];
                urlOriginalPretty = urlRedirect;
            }
            msg = `HTTP ${type} ${prettyUrl(urlOriginalPretty)} ${color(statusCode ?? 'ERR')}`;
        }
    }
    logRuntimeInfo?.(msg, httpRequestId, isNominal ? 'info' : 'error');
}
function prettyUrl(url) {
    return pc.bold(decodeURI(url));
}
function getPageContextHttpResponseError(err, pageContextInit, pageContext) {
    const pageContextWithError = createPageContext(pageContextInit);
    const httpResponse = createHttpResponseError(pageContext);
    objectAssign(pageContextWithError, {
        httpResponse,
        errorWhileRendering: err
    });
    return pageContextWithError;
}
function getPageContextHttpResponseFavicon404(pageContextInit) {
    const pageContext = createPageContext(pageContextInit);
    const httpResponse = createHttpResponseFavicon404();
    objectAssign(pageContext, {
        httpResponse
    });
    checkType(pageContext);
    return pageContext;
}
function createPageContext(pageContextInit) {
    const pageContext = {
        _isPageContextObject: true
    };
    Object.assign(pageContext, pageContextInit);
    return pageContext;
}
async function renderPageNominal(pageContext) {
    objectAssign(pageContext, { errorWhileRendering: null });
    // Route
    {
        const pageContextFromRoute = await route(pageContext);
        objectAssign(pageContext, pageContextFromRoute);
        objectAssign(pageContext, { is404: pageContext.pageId ? null : true });
        if (pageContext.pageId === null) {
            const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);
            if (!errorPageId) {
                assert(hasProp(pageContext, 'pageId', 'null'));
                return handleErrorWithoutErrorPage(pageContext);
            }
            objectAssign(pageContext, { pageId: errorPageId });
        }
    }
    assert(hasProp(pageContext, 'pageId', 'string'));
    assert(pageContext.errorWhileRendering === null);
    // Render
    const pageContextAfterRender = await renderPageAlreadyRouted(pageContext);
    assert(pageContext === pageContextAfterRender);
    return pageContextAfterRender;
}
async function getPageContextErrorPageInit(pageContextInit, errNominalPage, pageContextNominalPagePartial, renderContext, httpRequestId) {
    const pageContextInitEnhanced = getPageContextInitEnhancedSSR(pageContextInit, renderContext, null, httpRequestId);
    assert(errNominalPage);
    const pageContext = {};
    objectAssign(pageContext, pageContextInitEnhanced);
    objectAssign(pageContext, {
        is404: false,
        errorWhileRendering: errNominalPage,
        routeParams: {}
    });
    objectAssign(pageContext, {
        _debugRouteMatches: pageContextNominalPagePartial._debugRouteMatches || 'ROUTING_ERROR'
    });
    assert(pageContext.errorWhileRendering);
    return pageContext;
}
function getPageContextInitEnhancedSSR(pageContextInit, renderContext, urlRewrite, httpRequestId) {
    const { isClientSideNavigation, _urlHandler } = handlePageContextUrl(pageContextInit.urlOriginal);
    const pageContextInitEnhanced = getPageContextInitEnhanced(pageContextInit, renderContext, {
        ssr: {
            urlRewrite,
            urlHandler: _urlHandler,
            isClientSideNavigation
        }
    });
    objectAssign(pageContextInitEnhanced, { _httpRequestId: httpRequestId });
    return pageContextInitEnhanced;
}
function handlePageContextUrl(urlOriginal) {
    const { isPageContextRequest } = handlePageContextRequestUrl(urlOriginal);
    return {
        isClientSideNavigation: isPageContextRequest,
        _urlHandler: (url) => handlePageContextRequestUrl(url).urlWithoutPageContextRequestSuffix
    };
}
function getRequestId() {
    const httpRequestId = ++globalObject.httpRequestsCount;
    assert(httpRequestId >= 1);
    return httpRequestId;
}
function assertIsUrl(urlOriginal) {
    assertUsage(isUrl(urlOriginal), `${pc.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${pc.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which isn't a valid URL.`);
}
function assertIsNotViteRequest(urlPathname, urlOriginal) {
    const isViteRequest = urlPathname.startsWith('/@vite/client') || urlPathname.startsWith('/@fs/') || urlPathname.startsWith('/__vite_ping');
    assertUsage(!isViteRequest, `${pc.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${pc.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which is unexpected because this URL should have already been handled by Vite's development middleware. Make sure to 1. install Vite's development middleware and 2. add Vite's middleware *before* Vike's middleware, see https://vike.dev/renderPage`);
}
function normalizeUrl(pageContextInit, httpRequestId) {
    const { trailingSlash, disableUrlNormalization, baseServer } = getGlobalContext();
    if (disableUrlNormalization)
        return null;
    const { urlOriginal } = pageContextInit;
    const { isPageContextRequest } = handlePageContextRequestUrl(urlOriginal);
    if (isPageContextRequest)
        return null;
    const urlNormalized = normalizeUrlPathname(urlOriginal, trailingSlash, baseServer);
    if (!urlNormalized)
        return null;
    logRuntimeInfo?.(`URL normalized from ${pc.cyan(urlOriginal)} to ${pc.cyan(urlNormalized)} (https://vike.dev/url-normalization)`, httpRequestId, 'info');
    const httpResponse = createHttpResponseRedirect({ url: urlNormalized, statusCode: 301 }, pageContextInit.urlOriginal);
    const pageContextHttpResponse = createPageContext(pageContextInit);
    objectAssign(pageContextHttpResponse, { httpResponse });
    return pageContextHttpResponse;
}
function getPermanentRedirect(pageContextInit, httpRequestId) {
    const { redirects, baseServer } = getGlobalContext();
    const urlWithoutBase = removeBaseServer(pageContextInit.urlOriginal, baseServer);
    let origin = null;
    let urlTargetExternal = null;
    let urlTarget = modifyUrlPathname(urlWithoutBase, (urlPathname) => {
        const urlTarget = resolveRedirects(redirects, urlPathname);
        if (urlTarget === null)
            return null;
        if (!isUrl(urlTarget)) {
            // E.g. `urlTarget === 'mailto:some@example.com'`
            assert(isUri(urlTarget));
            urlTargetExternal = urlTarget;
            return null;
        }
        const { urlModified, origin: origin_ } = removeUrlOrigin(urlTarget);
        origin = origin_;
        return urlModified;
    });
    if (urlTargetExternal) {
        urlTarget = urlTargetExternal;
    }
    else {
        let originChanged = false;
        if (origin) {
            const urlModified = setUrlOrigin(urlTarget, origin);
            if (urlModified !== false) {
                originChanged = true;
                urlTarget = urlModified;
            }
        }
        if (normalize(urlTarget) === normalize(urlWithoutBase))
            return null;
        if (!originChanged)
            urlTarget = prependBase(urlTarget, baseServer);
        assert(urlTarget !== pageContextInit.urlOriginal);
    }
    logRuntimeInfo?.(`Permanent redirection defined by config.redirects (https://vike.dev/redirects)`, httpRequestId, 'info');
    const httpResponse = createHttpResponseRedirect({ url: urlTarget, statusCode: 301 }, urlWithoutBase);
    const pageContextHttpResponse = createPageContext(pageContextInit);
    objectAssign(pageContextHttpResponse, { httpResponse });
    return pageContextHttpResponse;
}
function normalize(url) {
    return url || '/';
}
async function handleAbortError(errAbort, pageContextsFromRewrite, pageContextInit, 
// handleAbortError() creates a new pageContext object and we don't merge pageContextNominalPageInit to it: we only use some pageContextNominalPageInit information.
pageContextNominalPageInit, httpRequestId, renderContext, pageContextErrorPageInit) {
    logAbortErrorHandled(errAbort, getGlobalContext().isProduction, pageContextNominalPageInit);
    const pageContextAbort = errAbort._pageContextAbort;
    let pageContextSerialized;
    if (pageContextNominalPageInit.isClientSideNavigation) {
        if (pageContextAbort.abortStatusCode) {
            const errorPageId = getErrorPageId(renderContext.pageFilesAll, renderContext.pageConfigs);
            const abortCall = pageContextAbort._abortCall;
            assert(abortCall);
            assertUsage(errorPageId, `You called ${pc.cyan(abortCall)} but you didn't define an error page, make sure to define one https://vike.dev/error-page`);
            const pageContext = createPageContext({});
            objectAssign(pageContext, { pageId: errorPageId });
            objectAssign(pageContext, pageContextAbort);
            objectAssign(pageContext, pageContextErrorPageInit);
            objectAssign(pageContext, renderContext);
            objectAssign(pageContext, await loadUserFilesServerSide(pageContext));
            // We include pageContextInit: we don't only serialize pageContextAbort because the error page may need to access pageContextInit
            pageContextSerialized = serializePageContextClientSide(pageContext);
        }
        else {
            pageContextSerialized = serializePageContextAbort(pageContextAbort);
        }
        const httpResponse = await createHttpResponsePageContextJson(pageContextSerialized);
        const pageContextReturn = { httpResponse };
        return { pageContextReturn };
    }
    if (pageContextAbort._urlRewrite) {
        const pageContextReturn = await renderPageAlreadyPrepared(pageContextInit, httpRequestId, renderContext, [
            ...pageContextsFromRewrite,
            pageContextAbort
        ]);
        Object.assign(pageContextReturn, pageContextAbort);
        return { pageContextReturn };
    }
    if (pageContextAbort._urlRedirect) {
        const pageContextReturn = createPageContext(pageContextInit);
        objectAssign(pageContextReturn, pageContextAbort);
        const httpResponse = createHttpResponseRedirect(pageContextAbort._urlRedirect, (() => {
            const { pathname, searchOriginal } = pageContextNominalPageInit.urlParsed;
            const urlLogical = createUrlFromComponents(null, pathname, searchOriginal, 
            // The server-side doesn't have access to the hash
            null);
            return urlLogical;
        })());
        objectAssign(pageContextReturn, { httpResponse });
        return { pageContextReturn };
    }
    assert(pageContextAbort.abortStatusCode);
    return { pageContextAbort };
}
function assertBaseUrl(pageContextInit) {
    const { baseServer } = getGlobalContext();
    const { urlOriginal } = pageContextInit;
    const { urlWithoutPageContextRequestSuffix } = handlePageContextRequestUrl(urlOriginal);
    const { hasBaseServer } = parseUrl(urlWithoutPageContextRequestSuffix, baseServer);
    assertUsage(hasBaseServer, `${pc.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${pc.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which doesn't start with Base URL ${pc.code(baseServer)} (https://vike.dev/base-url)`);
}
