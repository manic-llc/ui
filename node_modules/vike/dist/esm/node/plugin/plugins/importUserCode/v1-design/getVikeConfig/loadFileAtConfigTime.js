// Files loadded at config time:
export { loadImportedFile };
export { loadValueFile };
export { loadConfigFile };
import { assert, assertUsage, hasProp, assertIsNotProductionRuntime } from '../../../../utils.js';
import { transpileAndExecuteFile } from './transpileAndExecuteFile.js';
import { assertPlusFileExport } from '../../../../../../shared/page-configs/assertPlusFileExport.js';
import pc from '@brillout/picocolors';
import { parsePointerImportData } from './transformPointerImports.js';
import { getConfigFileExport } from '../getConfigFileExport.js';
import { resolvePointerImport } from './resolvePointerImport.js';
assertIsNotProductionRuntime();
// Load pointer import
async function loadImportedFile(import_, userRootDir, importedFilesLoaded) {
    const f = import_.filePathAbsoluteFilesystem;
    if (!importedFilesLoaded[f]) {
        importedFilesLoaded[f] = transpileAndExecuteFile(import_, userRootDir, false).then((r) => r.fileExports);
    }
    const fileExports = await importedFilesLoaded[f];
    const fileExport = fileExports[import_.fileExportName];
    return fileExport;
}
// Load +{configName}.js
async function loadValueFile(interfaceValueFile, configName, userRootDir) {
    const { fileExports } = await transpileAndExecuteFile(interfaceValueFile.filePath, userRootDir, false);
    const { filePathToShowToUser } = interfaceValueFile.filePath;
    assertPlusFileExport(fileExports, filePathToShowToUser, configName);
    Object.entries(fileExports).forEach(([exportName, configValue]) => {
        const configName_ = exportName === 'default' ? configName : exportName;
        interfaceValueFile.fileExportsByConfigName[configName_] = { configValue };
    });
}
// Load +config.js, including all its extends pointer imports
async function loadConfigFile(configFilePath, userRootDir, visited, isExtensionConfig) {
    const { filePathAbsoluteFilesystem } = configFilePath;
    assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem);
    const { fileExports } = await transpileAndExecuteFile(configFilePath, userRootDir, isExtensionConfig ? 'is-extension-config' : true);
    const { extendsConfigs, extendsFilePaths } = await loadExtendsConfigs(fileExports, configFilePath, userRootDir, [
        ...visited,
        filePathAbsoluteFilesystem
    ]);
    const configFile = {
        fileExports,
        filePath: configFilePath,
        extendsFilePaths
    };
    return { configFile, extendsConfigs };
}
function assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem) {
    const idx = visited.indexOf(filePathAbsoluteFilesystem);
    if (idx === -1)
        return;
    const loop = visited.slice(idx);
    assert(loop[0] === filePathAbsoluteFilesystem);
    assertUsage(idx === -1, `Infinite extends loop ${[...loop, filePathAbsoluteFilesystem].join('>')}`);
}
async function loadExtendsConfigs(configFileExports, configFilePath, userRootDir, visited) {
    const extendsPointerImportData = getExtendsPointerImportData(configFileExports, configFilePath);
    const extendsConfigFiles = [];
    extendsPointerImportData.map((pointerImportData) => {
        const filePath = resolvePointerImport(pointerImportData, configFilePath, userRootDir);
        assert(filePath.filePathAbsoluteFilesystem);
        extendsConfigFiles.push(filePath);
    });
    const extendsConfigs = [];
    await Promise.all(extendsConfigFiles.map(async (configFilePath) => {
        const result = await loadConfigFile(configFilePath, userRootDir, visited, true);
        extendsConfigs.push(result.configFile);
        extendsConfigs.push(...result.extendsConfigs);
    }));
    const extendsFilePaths = extendsConfigFiles.map((f) => f.filePathAbsoluteFilesystem);
    return { extendsConfigs, extendsFilePaths };
}
function getExtendsPointerImportData(configFileExports, configFilePath) {
    const { filePathToShowToUser } = configFilePath;
    const configFileExport = getConfigFileExport(configFileExports, filePathToShowToUser);
    const wrongUsage = `${filePathToShowToUser} sets the config ${pc.cyan('extends')} to an invalid value, see https://vike.dev/extends`;
    let extendList;
    if (!('extends' in configFileExport)) {
        return [];
    }
    else if (hasProp(configFileExport, 'extends', 'string')) {
        extendList = [configFileExport.extends];
    }
    else if (hasProp(configFileExport, 'extends', 'string[]')) {
        extendList = configFileExport.extends;
    }
    else {
        assertUsage(false, wrongUsage);
    }
    const extendsPointerImportData = extendList.map((importString) => {
        const pointerImportData = parsePointerImportData(importString);
        assertUsage(pointerImportData, wrongUsage);
        return pointerImportData;
    });
    return extendsPointerImportData;
}
